<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog</title>
  
  <subtitle>博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zfdev.com/"/>
  <updated>2019-06-30T09:52:22.639Z</updated>
  <id>https://zfdev.com/</id>
  
  <author>
    <name>Greendev</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>温故而知新-2：对象与继承</title>
    <link href="https://zfdev.com/20190630/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0-2/"/>
    <id>https://zfdev.com/20190630/温故而知新-2/</id>
    <published>2019-06-30T05:44:00.000Z</published>
    <updated>2019-06-30T09:52:22.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JavaScript-创建对象的几种方式？"><a href="#1-JavaScript-创建对象的几种方式？" class="headerlink" title="1. JavaScript 创建对象的几种方式？"></a>1. JavaScript 创建对象的几种方式？</h2><ol><li><p>对象字面量、Object构造函数</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象字面量</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.gender = <span class="string">"女"</span>;</span><br><span class="line">obj[<span class="string">"age"</span>] = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Object构造函数</span></span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li><li><p>构造函数  </p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.job=job;</span><br><span class="line">    <span class="keyword">this</span>.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(...);</span><br><span class="line"> <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(...);</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>纯构造函数   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>空构造函数 + 原型   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>混合构造函数 + 原型   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">sColor,iDoors,iMpg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = sColor;</span><br><span class="line">    <span class="keyword">this</span>.doors = iDoors;</span><br><span class="line">    <span class="keyword">this</span>.mpg = iMpg;</span><br><span class="line">    <span class="keyword">this</span>.drivers = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Mike"</span>,<span class="string">"John"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Car.prototype.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car(<span class="string">"red"</span>,<span class="number">4</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> oCar2 = <span class="keyword">new</span> Car(<span class="string">"blue"</span>,<span class="number">3</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>动态原型  </p><blockquote><p>动态原型模式将所有信息都封装在了构造函数中，初始化的时候，通过检测某个应该存在的方法时候有效，来决定是否需要初始化原型  </p></blockquote> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, job</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 属性 </span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">// 方法 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName !== <span class="string">'function'</span>) &#123; </span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Jiang'</span>, <span class="string">'Student'</span>);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure></li></ol><ol start="7"><li><p>寄生构造函数  </p><blockquote><p>这种模式的基本思想就是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新建的对象  </p></blockquote> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, job</span>) </span>&#123; </span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>() </span><br><span class="line">    o.name = name;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">'Jiang'</span>, <span class="string">'student'</span>);</span><br><span class="line">person1.sayName();</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li>Object.create() - ES5   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(persons); <span class="comment">//继承父类的属性</span></span><br><span class="line">child.name = <span class="string">'jack'</span>;</span><br><span class="line">child.sex = <span class="string">'nan'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(child);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果类似</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        result[prop] = obj[prop];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 让result具有obj一样的构造函数</span></span><br><span class="line">    result.constructor = obj.constructor;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="2-JavaScript-如何实现继承？"><a href="#2-JavaScript-如何实现继承？" class="headerlink" title="2.JavaScript 如何实现继承？"></a>2.JavaScript 如何实现继承？</h2><ul><li><p>原型链继承  </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = <span class="string">'jacy'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">   cat.name; <span class="comment">// "jacy"</span></span><br><span class="line">   cat.age; <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></li><li><p>借用结构函数继承  </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     Animal.call(<span class="keyword">this</span>); <span class="comment">// 让Cat所有对象借用Animal对象的构造函数</span></span><br><span class="line">     <span class="keyword">this</span>.name = <span class="string">'jacy'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Cat.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">   cat.name; <span class="comment">// "jacy"</span></span><br><span class="line">   cat.age; <span class="comment">// 20</span></span><br></pre></td></tr></table></figure></li><li><p>原型 + 构造函数组合继承</p></li><li><p>寄生式继承  </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">age, sex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  obj.age = age;</span><br><span class="line">  obj.sex = sex;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 寄生模式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Japanese</span>(<span class="params">name, language</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.language = language;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChinese</span>(<span class="params">name, language</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  Japanese.call(obj, name, language);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-JavaScript-创建对象的几种方式？&quot;&gt;&lt;a href=&quot;#1-JavaScript-创建对象的几种方式？&quot; class=&quot;headerlink&quot; title=&quot;1. JavaScript 创建对象的几种方式？&quot;&gt;&lt;/a&gt;1. JavaScript 创建
      
    
    </summary>
    
      <category term="前端" scheme="https://zfdev.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="https://zfdev.com/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="javascript" scheme="https://zfdev.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>温故而知新-1</title>
    <link href="https://zfdev.com/20190630/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0-1/"/>
    <id>https://zfdev.com/20190630/温故而知新-1/</id>
    <published>2019-06-29T18:36:00.000Z</published>
    <updated>2019-06-29T19:37:41.906Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-JavaScript的typeof返回哪些数据类型？"><a href="#1-JavaScript的typeof返回哪些数据类型？" class="headerlink" title="1. JavaScript的typeof返回哪些数据类型？"></a>1. JavaScript的typeof返回哪些数据类型？</h2><ul><li>object</li><li>number</li><li>string</li><li>boolean</li><li>function</li></ul><h2 id="2-检查数组的几种方式："><a href="#2-检查数组的几种方式：" class="headerlink" title="2. 检查数组的几种方式："></a>2. 检查数组的几种方式：</h2><ul><li><code>Array.isArray();</code> // es5  </li><li><code>toString.call([]);</code>    // [Object Array]</li><li><code>var arr = []; arr.constructor === Array;</code></li><li><code>var arr = []; arr instanceof Array;</code></li></ul><h2 id="3-传统事件绑定和符合W3C标准的事件绑定有什么区别？"><a href="#3-传统事件绑定和符合W3C标准的事件绑定有什么区别？" class="headerlink" title="3. 传统事件绑定和符合W3C标准的事件绑定有什么区别？"></a>3. 传统事件绑定和符合W3C标准的事件绑定有什么区别？</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div1.onclick = function()&#123;&#125;;</span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onmouseover</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="传统时间绑定"><a href="#传统时间绑定" class="headerlink" title="传统时间绑定"></a>传统时间绑定</h3><ol><li>如果给同一个元素绑定了多次相同类型的事件，那么后面的绑定会覆盖前面的绑定</li><li>不支持<strong>DOM事件流</strong><br> 时间捕获阶段=&gt;目标元素解读=&gt;时间冒泡阶段</li></ol><h3 id="符合W3C标准的事件绑定方式"><a href="#符合W3C标准的事件绑定方式" class="headerlink" title="符合W3C标准的事件绑定方式"></a>符合W3C标准的事件绑定方式</h3><blockquote><p>addEventListener<br>attachEvent  </p></blockquote><h4 id="A-非IE浏览器："><a href="#A-非IE浏览器：" class="headerlink" title="A.非IE浏览器："></a>A.非IE浏览器：</h4><ul><li>addEventListener<ol><li>如果给同一个元素绑定了多次相同类型的事件，所有答绑定将会一次触发</li><li>支持DOM事件流</li><li>进行事件绑定传参不需要<code>on</code>前缀  </li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 此时的事件在捕获阶段执行，第三个参数：是否在捕获阶段执行，默认false(在冒泡阶段执行)</span></span><br></pre></td></tr></table></figure><h4 id="B-IE浏览器"><a href="#B-IE浏览器" class="headerlink" title="B.IE浏览器"></a>B.IE浏览器</h4><ul><li>ie9开始，ie11, edge: addEventListener  </li><li>ie9以前：attachEvent/detachEvent<ol><li>进行事件类型传参需要带上<code>on</code>前缀</li><li>进行这种方式只支持事件冒泡，不支持事件捕获  </li></ol></li></ul><h2 id="4-IE和标准下有哪些兼容性的写法"><a href="#4-IE和标准下有哪些兼容性的写法" class="headerlink" title="4.IE和标准下有哪些兼容性的写法"></a>4.IE和标准下有哪些兼容性的写法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ev = ev || <span class="built_in">window</span>.event <span class="comment">// 获取触发事件答对象</span></span><br><span class="line"><span class="keyword">var</span> target = ev.srcElement || ev.target <span class="comment">// 获取事件答源对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth</span><br></pre></td></tr></table></figure><h2 id="5-call和apply的区别"><a href="#5-call和apply的区别" class="headerlink" title="5. call和apply的区别"></a>5. call和apply的区别</h2><ul><li><p>相同点<br>  都是为了让一个对象执行本不属于它的方法</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">toString.call([], <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">toString.apply([], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.call(<span class="keyword">this</span>, obj1, obj2, obj3)</span><br><span class="line"><span class="built_in">Object</span>.apply([], <span class="built_in">arguments</span>)</span><br></pre></td></tr></table></figure></li><li><p>不同点  </p><ul><li>call 第二个参数开始接受一个参数列表</li><li>apply 第二个参数开始接受一个参数数组</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-JavaScript的typeof返回哪些数据类型？&quot;&gt;&lt;a href=&quot;#1-JavaScript的typeof返回哪些数据类型？&quot; class=&quot;headerlink&quot; title=&quot;1. JavaScript的typeof返回哪些数据类型？&quot;&gt;&lt;/a&gt;1
      
    
    </summary>
    
      <category term="前端" scheme="https://zfdev.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="基础" scheme="https://zfdev.com/categories/%E5%89%8D%E7%AB%AF/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaScript" scheme="https://zfdev.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>C# NPOI Excel单元格样式修改</title>
    <link href="https://zfdev.com/20190109/C-NPOI-%E5%8D%95%E5%85%83%E6%A0%BC%E6%A0%B7%E5%BC%8F%E4%BF%AE%E6%94%B9/"/>
    <id>https://zfdev.com/20190109/C-NPOI-单元格样式修改/</id>
    <published>2019-01-09T12:09:00.000Z</published>
    <updated>2019-01-09T12:14:01.360Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 创建样式</span></span><br><span class="line">ICellStyle headerCellStyle = workbook.CreateCellStyle();</span><br><span class="line"><span class="comment">// 设置填充模式</span></span><br><span class="line">headerCellStyle.FillPattern = FillPattern.SolidForeground;</span><br><span class="line"><span class="comment">// 填充颜色</span></span><br><span class="line">headerCellStyle.FillForegroundColor = IndexedColors.Tan.Index;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置边框</span></span><br><span class="line">headerCellStyle.BorderBottom =</span><br><span class="line">    headerCellStyle.BorderRight =</span><br><span class="line">    headerCellStyle.BorderTop =</span><br><span class="line">    headerCellStyle.BorderLeft = NPOI.SS.UserModel.BorderStyle.Thin;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="NPOI" scheme="https://zfdev.com/categories/C/NPOI/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="NPOI" scheme="https://zfdev.com/tags/NPOI/"/>
    
      <category term="CellStyle" scheme="https://zfdev.com/tags/CellStyle/"/>
    
      <category term="Excel" scheme="https://zfdev.com/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>C# NPOI 添加修改Excel文件属性</title>
    <link href="https://zfdev.com/20190109/C-NPOI-%E6%B7%BB%E5%8A%A0%E4%BF%AE%E6%94%B9Excel%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7/"/>
    <id>https://zfdev.com/20190109/C-NPOI-添加修改Excel文件属性/</id>
    <published>2019-01-09T12:02:00.000Z</published>
    <updated>2019-01-09T12:13:20.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HSSFWorkbook-xls"><a href="#HSSFWorkbook-xls" class="headerlink" title="HSSFWorkbook(.xls)"></a>HSSFWorkbook(.xls)</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">HSSFWorkbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line"></span><br><span class="line">DocumentSummaryInformation dsi = PropertySetFactory.CreateDocumentSummaryInformation();</span><br><span class="line">dsi.Company = <span class="string">"Company"</span>;</span><br><span class="line">dsi.Category = <span class="string">"Category"</span>;</span><br><span class="line">dsi.Manager = <span class="string">"Manager"</span>;</span><br><span class="line"></span><br><span class="line">SummaryInformation si = PropertySetFactory.CreateSummaryInformation();</span><br><span class="line">si.Subject = <span class="string">"Subject"</span>;</span><br><span class="line">si.Title = <span class="string">"Title"</span>;</span><br><span class="line">si.ApplicationName = <span class="string">"ApplicationName"</span>;</span><br><span class="line">si.Author = <span class="string">"Author"</span>;</span><br><span class="line">si.LastAuthor = <span class="string">"LastAuthor"</span>;</span><br><span class="line">si.Comments = <span class="string">"Comments"</span>;</span><br><span class="line">si.CreateDateTime = DateTime.Now.AddMonths(<span class="number">-2</span>);</span><br><span class="line"></span><br><span class="line">workbook.DocumentSummaryInformation = dsi;</span><br><span class="line">workbook.SummaryInformation = si;</span><br></pre></td></tr></table></figure><h2 id="XSSFWorkbook-xlsx"><a href="#XSSFWorkbook-xlsx" class="headerlink" title="XSSFWorkbook(.xlsx)"></a>XSSFWorkbook(.xlsx)</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">XSSFWorkbook workbook = <span class="keyword">new</span> XSSFWorkbook();</span><br><span class="line"></span><br><span class="line">POIXMLProperties xmlprops = workbook.GetProperties();</span><br><span class="line">xmlprops.CoreProperties.Creator = <span class="string">"Creator"</span>;</span><br><span class="line">xmlprops.CoreProperties.Subject = <span class="string">"Subject"</span>;</span><br><span class="line">xmlprops.CoreProperties.Category = <span class="string">"Category"</span>;</span><br><span class="line">xmlprops.CoreProperties.Title = <span class="string">"Title"</span>;</span><br><span class="line">xmlprops.CoreProperties.ContentStatus = <span class="string">"ContentStatus"</span>;</span><br><span class="line">xmlprops.CoreProperties.ContentType = <span class="string">"ContentType"</span>;</span><br><span class="line">xmlprops.CoreProperties.Description = <span class="string">"Description"</span>;</span><br><span class="line">xmlprops.CoreProperties.Identifier = <span class="string">"Identifier"</span>;</span><br><span class="line">xmlprops.CoreProperties.Keywords = <span class="string">"Keywords"</span>;</span><br><span class="line">xmlprops.CoreProperties.Revision = <span class="string">"Revision"</span>;</span><br><span class="line"></span><br><span class="line">CT_ExtendedProperties ctprops = xmlprops.ExtendedProperties.GetUnderlyingProperties();</span><br><span class="line">ctprops.Application = (<span class="string">"Application"</span>);</span><br><span class="line">ctprops.Company = (<span class="string">"Company"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HSSFWorkbook-xls&quot;&gt;&lt;a href=&quot;#HSSFWorkbook-xls&quot; class=&quot;headerlink&quot; title=&quot;HSSFWorkbook(.xls)&quot;&gt;&lt;/a&gt;HSSFWorkbook(.xls)&lt;/h2&gt;&lt;figure class
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="NPOI" scheme="https://zfdev.com/categories/C/NPOI/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="NPOI" scheme="https://zfdev.com/tags/NPOI/"/>
    
      <category term="EXCEL" scheme="https://zfdev.com/tags/EXCEL/"/>
    
  </entry>
  
  <entry>
    <title>Easy HTTP–not Just a Catchy Name</title>
    <link href="https://zfdev.com/20190106/Easy-HTTP%E2%80%93not-Just-a-Catchy-Name/"/>
    <id>https://zfdev.com/20190106/Easy-HTTP–not-Just-a-Catchy-Name/</id>
    <published>2019-01-06T08:56:00.000Z</published>
    <updated>2019-01-06T10:31:43.299Z</updated>
    
    <content type="html"><![CDATA[<p>I was recently referred to <a href="http://nuget.org/List/Packages/EasyHttp" target="_blank" rel="noopener">EasyHTTP</a> by it’s creator, <a href="http://twitter.com/hhariri" target="_blank" rel="noopener">Hadi Hariri</a>. Hadi was looking at some code I had sent him regarding my work with the <a href="http://jetbrains.com/teamcity" target="_blank" rel="noopener">TeamCity</a> REST API and thought that things could be a little easier and less verbose.</p><p>我最近被它的创造者Hadi Hariri称为<a href="http://nuget.org/List/Packages/EasyHttp" target="_blank" rel="noopener">EasyHTTP</a>。</p><p>Hadi正在查看我发给他的关于我使用<a href="http://jetbrains.com/teamcity" target="_blank" rel="noopener">TeamCity</a> REST API的一些代码，并认为事情可能会更简单，更简洁。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Caller</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Uri <span class="title">CreateUri</span>(<span class="params"><span class="keyword">string</span> relativeUrl</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="comment">//url build here</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> HttpWebRequest <span class="title">CreateWebRequest</span>(<span class="params">Uri uri</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(uri);</span><br><span class="line">            webRequest.Credentials = <span class="keyword">new</span> NetworkCredential(_configuration.UserName,</span><br><span class="line">                _configuration.Password);</span><br><span class="line">            webRequest.Proxy = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> (webRequest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">string</span> <span class="title">Request</span>(<span class="params">Uri uri</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            HttpWebRequest webRequest = CreateWebRequest(uri);</span><br><span class="line">            webRequest.Accept = <span class="string">"application/json"</span>;</span><br><span class="line">            <span class="keyword">string</span> output = <span class="keyword">string</span>.Empty;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">using</span> (<span class="keyword">var</span> response = webRequest.GetResponse())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> StreamReader(response.GetResponseStream(), Encoding.GetEncoding(<span class="number">1252</span>)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        output = stream.ReadToEnd();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (WebException ex)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ex.Status == WebExceptionStatus.ProtocolError)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">using</span> (<span class="keyword">var</span> stream = <span class="keyword">new</span> StreamReader(ex.Response.GetResponseStream()))</span><br><span class="line">                    &#123;</span><br><span class="line">                        output = stream.ReadToEnd();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ex.Status == WebExceptionStatus.Timeout)</span><br><span class="line">                &#123;</span><br><span class="line">                    output = <span class="string">"Request timeout is expired."</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> output;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>In summary my application creates a new HttpWebRequest passing in the request type as a magic string. It opens a stream to read the JSON response and that JSON is then de-serialised to an entity. It was very messy. In order to call this class from my application I would have had to do the follow:</p><p>总之，我的应用程序创建了一个新的<code>HttpWebRequest</code>，将请求类型作为魔术字符串(magic string)传递。 它打开一个流来读取JSON响应，然后将JSON反序列化为实体。 这非常凌乱。 为了从我的应用程序中调用此类，我将不得不执行以下操作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerable&lt;Project&gt; <span class="title">GetAllProjects</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> uri = _caller.CreateUri(<span class="string">"/URL"</span>);</span><br><span class="line">    <span class="keyword">var</span> request = _caller.Request(uri);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> projects = JsonConvert.DeserializeObject&lt;ProjectWrapper&gt;(request).Projects;</span><br><span class="line">    <span class="keyword">return</span> projects;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There is absolutely no mention of whether the request was a GET never mind a PUT or a DELETE. This is where EasyHTTP came in for me.</p><p>绝对没有提到请求是否是GET，PUT还是DELETE。 这就是EasyHTTP为我提供的地方。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Caller</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T Get&lt;T&gt;(<span class="keyword">string</span> urlPart)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> request = CreateHttpRequest(_configuration.UserName, _configuration.Password);</span><br><span class="line">        <span class="keyword">string</span> url = CreateUrl(urlPart);</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> staticBody = request.Get(url).StaticBody&lt;T&gt;();</span><br><span class="line">            <span class="keyword">return</span> staticBody;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (HttpException ex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//do something here for an outut</span></span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">string</span> <span class="title">CreateUrl</span>(<span class="params"><span class="keyword">string</span> urlPart</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> protocol = _configuration.UseSSL ? <span class="string">"https://"</span> : <span class="string">"http://"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;&#123;1&#125;&#123;2&#125;"</span>, protocol, _configuration.HostName, urlPart);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">HttpClient <span class="title">CreateHttpRequest</span>(<span class="params"><span class="keyword">string</span> userName, <span class="keyword">string</span> password</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">        httpClient.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line">        httpClient.Request.SetBasicAuthentication(userName, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> httpClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I was able to make a generic method for a GET request. This method takes a url and a type and with the help of <a href="http://jsonfx.net/" target="_blank" rel="noopener">JsonFx</a>, de-serialises the response back to the requested type. THis was a great way to take the hassle out of my old code where I was creating a Url, calling a request and then de-serialising it. The code in the calling class now looks as follows:</p><p>我能够为GET请求创建一个通用方法。<br>此方法采用url和类型，并在<a href="http://jsonfx.net/" target="_blank" rel="noopener">JsonFx</a>的帮助下，将响应内容(response)反序列化回请求的类型。 这是解决我的旧代码的麻烦的一个很好的方式，我在创建一个Url，调用请求然后反序列化它。 调用类中的代码现在看起来如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Project&gt; <span class="title">GetAllProjects</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> projectWrapper = _caller.Get&lt;ProjectWrapper&gt;(<span class="string">"/Url"</span>);</span><br><span class="line">    <span class="keyword">return</span> projectWrapper.Project;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>I was originally using the <a href="http://james.newtonking.com/pages/json-net.aspx" target="_blank" rel="noopener">Newtonsoft JSON library</a> for my de-serialising my JSON back to types and to do that I had to decorate the properties with code similar to the following:</p><p>我最初使用<a href="http://james.newtonking.com/pages/json-net.aspx" target="_blank" rel="noopener">Newtonsoft JSON library</a>将我的JSON反序列化为类型，为此我必须使用它来装饰属性 代码类似于以下内容：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">JsonProperty(PropertyName = “id”)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">string</span> Id &#123;<span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br></pre></td></tr></table></figure><p>This would effectively map a piece of JSON to a property that was not named <strong>exactly</strong> the same. EasyHTTP took care of this for me as well. To quote Hadi, EasyHTTP handles mapping as follows:</p><p>这样可以有效地将一段JSON映射到一个未命名为 <strong>exactly</strong>的属性。 EasyHTTP也为我解决了这个问题。 引用Hadi，EasyHTTP处理映射如下：</p><p><em>“For mapping properties, it handles camelcase, lowercase and a bunch of other conventions. You can also specify explicitly”</em></p><p><em>“对于映射属性，它处理camelcase，小写和一些其他约定。 你也可以明确指定”</em></p><p>Using EasyHTTP, I was able to cut at least 2 lines of code per method in the client code. I was also able to delete an attribute that was present on <strong>all properties in the entities</strong> in a little bit of work.</p><p>使用EasyHTTP，我能够在客户端代码中为每个方法删除至少2行代码。 我还能够在一些工作中删除<strong>实体中的所有属性</strong>。</p><p>The added distinction of creating the notion of GETs, PUTs and DELETE calls from each other mean that my class can be extended much easier. Hadi has written a post on EasyHTTP on <a href="http://hadihariri.com/2011/01/16/easyhttp/" target="_blank" rel="noopener">his blog</a>. I would strongly suggest reading this and discovering if you can use this application in place of old HttpWebRequest calls. Its cleaner and helps to make code a little bit more DRY. My thanks to Hadi (and any contributors there may be) for making my work in this area a little easier!</p><p>创建GET，PUT和DELETE调用概念的额外区别意味着我的类可以更容易地扩展。 Hadi在<a href="http://hadihariri.com/2011/01/16/easyhttp/" target="_blank" rel="noopener">他的博客</a>上写了一篇关于EasyHTTP的文章。 我强烈建议阅读本文并发现是否可以使用此应用程序代替旧的HttpWebRequest调用。 它更干净，有助于使代码更简练。 我要感谢Hadi（以及可能的任何贡献者）让我在这方面的工作变得更轻松！</p><ul><li><a href="http://www.paulstack.co.uk/blog/2011/07/15/easy-http-not-just-a-catchy-name" target="_blank" rel="noopener">Easy HTTP–not just a catchy name by Paul Stack</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I was recently referred to &lt;a href=&quot;http://nuget.org/List/Packages/EasyHttp&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EasyHTTP&lt;/a&gt; by it’s creator,
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="reprint" scheme="https://zfdev.com/categories/C/EasyHTTP/reprint/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="reprint" scheme="https://zfdev.com/tags/reprint/"/>
    
  </entry>
  
  <entry>
    <title>Easyhttp by Hadi Hariri</title>
    <link href="https://zfdev.com/20190106/Easyhttp-by-Hadi-Hariri/"/>
    <id>https://zfdev.com/20190106/Easyhttp-by-Hadi-Hariri/</id>
    <published>2019-01-06T08:44:00.000Z</published>
    <updated>2019-01-06T10:32:29.324Z</updated>
    
    <content type="html"><![CDATA[<p>最近，我编写的大部分代码都以某种方式与HTTP服务器进行通信。 无论是“ReSTful”服务还是“Wanna-be-ReSTful”服务，我都需要进行GET，POST，PUT等操作并与JSON配合。</p><p>在几次围绕<strong>WebRequest</strong>进行简单封装之后，我决定是时候将其正式化。<br>于是就有了<strong>EasyHttp</strong>。<br>它已经在<a href="http://github.com/hhariri/EasyHttp" target="_blank" rel="noopener">GitHub</a>上待了很长一段时间，我和其他人一直在将它用于几个项目，所以我认为它已经到了让更多人尝试的时候了，如果他们愿意的话。</p><p>描述<strong>EasyHttp</strong>功能的最佳方法就是代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient</span><br><span class="line">&#123;</span><br><span class="line">    Request = &#123; Accept = HttpContentTypes.ApplicationJson &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> response = http.Get(<span class="string">"http://domain.com/customer/25"</span>);</span><br><span class="line"><span class="keyword">var</span> customer = response.StaticBody&lt;Customer&gt;();</span><br></pre></td></tr></table></figure><p>代码描述：我们创建了一个<strong>HttpClient</strong>实例，并指示我们接受内容类型<code>application/json</code>（因为在这种情况下，服务器返回给我们的是json）。 通过指定此<code>Accept</code>头，<strong>EasyHttp</strong>知道如何解码请求（<code>request</code>）。</p><p>我们如何得到响应(<code>response</code>)？<br>在上面的代码中，我们使用<strong>StaticBody</strong>方法，它为我们提供了一个强类型客户(strongly-typed Customer)。 但我们还有其他选择：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient</span><br><span class="line">&#123;</span><br><span class="line">    Request = &#123; Accept = HttpContentTypes.ApplicationJson &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> response = http.Get(<span class="string">"http://domain.com/customer/25"</span>);</span><br><span class="line"><span class="keyword">dynamic</span> customer = response.DynamicBody();</span><br><span class="line">Console.WriteLine(customer.Name);</span><br><span class="line">Console.WriteLine(customer.Email);</span><br></pre></td></tr></table></figure><p>在这种情况下，我们想要返回一个动态类型，因此我们调用<strong>DynamicBody</strong>方法。<br><strong>EasyHttp</strong>将自动反序列化对动态对象的响应。<br>这允许我们访问属性而不必提前声明类型（在使用JSON时非常有用）。<br>最后，我们还可以通过<strong>RawText</strong>属性访问原始响应。</p><p>如果我们想要数据流(<code>stream</code>)传输到文件，我们只需：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.GetAsFile(<span class="string">"http://hadihariri.com/header.png"</span>, <span class="string">@"C:\Temp\header.png"</span>);</span><br></pre></td></tr></table></figure><p>使用其他方法(<code>Http verbs</code>)几乎是相同的过程。<br>假设我们想要创建一个调用服务的客户端：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> customer = <span class="keyword">new</span> Customer()</span><br><span class="line">&#123;</span><br><span class="line">    Name = <span class="string">"Joe Smith"</span>,</span><br><span class="line">    Email = <span class="string">"Joe@Gmail.com"</span></span><br><span class="line">&#125;;</span><br><span class="line">http.Post(<span class="string">"http://domain.com/customer"</span>, customer, HttpContentTypes.ApplicationJson);</span><br></pre></td></tr></table></figure><p>在这种情况下，我们提交了一个<strong>Customer</strong>对象，并要求<strong>EasyHttp</strong>使用<code>application/json</code>对其进行编码。<br>与接收响应时类似，在发出需求正文的请求时，我们也可以使用动态对象。<br>因此，这也可以使用：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient()</span><br><span class="line"><span class="keyword">dynamic</span> customer = <span class="keyword">new</span> ExpandoObject()</span><br><span class="line">customer.Name = <span class="string">"Joe Smith"</span>;</span><br><span class="line">customer.Email = <span class="string">"Joe@Gmail.com"</span>;</span><br><span class="line">http.Post(<span class="string">"http://domain.com/customer"</span>, customer, HttpContentTypes.ApplicationJson);</span><br></pre></td></tr></table></figure><p>在内部，<strong>EasyHttp</strong>正在使用优秀的<strong>JsonFX</strong>，它目前支持JSON和XML 编码和解码。<br><strong>EasyHttp</strong>通过添加<code>www-form-urlencoded</code>的编码支持来扩展它。<br>用其他格式扩展它应该很容易。</p><p>除了<strong>GET</strong>和<strong>POST</strong>，<strong>EasyHttp</strong>还支持<strong>PUT</strong>，<strong>DELETE</strong>和<strong>HEAD</strong>。<br>请求和响应标头作为属性显示，因此我们不必手动添加标头，而是可以单独分配它们（其中一些标记来自现有的<code>WebRequest</code>）。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这就是它的全部内容。 正如我所提到的，我一直在使用它与CouchDB交互，作为<a href="http://github.com/hhariri/YouTrackSharp" target="_blank" rel="noopener">YouTrackSharp</a>和其他一些项目的一部分。<br>它远不是全部功能，但是我添加的东西，因为我或部分人需要使用它们。</p><p>随意下载并使用它。<br>源代码在<a href="http://github.com/hhariri/EasyHttp" target="_blank" rel="noopener">GitHub</a>上，Issue Tracker在<a href="http://youtrack.codebetter.com/issues/EHTTP" target="_blank" rel="noopener">CodeBetter</a>上。<br>如果您对运行测试感兴趣，则需要CouchDB。<br>我最初写这篇文章是因为我需要为CouchDB做一些事情，它是测试不同Http Verbs的一个很好的平台（是的，它们是集成测试，而不是单元测试）。</p><ul><li><a href="https://hadihariri.com/2011/01/16/easyhttp/" target="_blank" rel="noopener">by Hadi Hariri</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近，我编写的大部分代码都以某种方式与HTTP服务器进行通信。 无论是“ReSTful”服务还是“Wanna-be-ReSTful”服务，我都需要进行GET，POST，PUT等操作并与JSON配合。&lt;/p&gt;
&lt;p&gt;在几次围绕&lt;strong&gt;WebRequest&lt;/stron
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="reprint" scheme="https://zfdev.com/categories/C/EasyHTTP/reprint/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="reprint" scheme="https://zfdev.com/tags/reprint/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Home</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Home/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Home/</id>
    <published>2019-01-06T08:15:00.000Z</published>
    <updated>2019-01-06T09:19:00.188Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to the EasyHttp wiki!</p><h2 id="Nuget"><a href="#Nuget" class="headerlink" title="Nuget"></a>Nuget</h2><p><a href="http://nuget.org/packages/EasyHttp" target="_blank" rel="noopener">nuget包</a> 可以在nuget库中找到。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><a href="/20190106/EasyHTTP-Httpclient/">HttpClient</a></li><li><a href="/20190106/EasyHTTP-Request/">Request</a></li><li><a href="/20190106/EasyHTTP-Response/">Response</a></li><li><a href="/20190106/EasyHTTP-Get/">Get</a></li><li><a href="/20190106/EasyHTTP-Post/">Post</a></li><li><a href="/20190106/EasyHTTP-Put/">Put</a></li><li><a href="#">Patch</a></li><li><a href="#">Options</a></li><li><a href="/20190106/EasyHTTP-Head/">Head</a></li><li><a href="/20190106/EasyHTTP-Delete/">Delete</a></li><li><a href="/20190106/EasyHTTP-Httpstatuscode/">HttpStatusCodes</a></li></ul><h2 id="Blogs-and-articles"><a href="#Blogs-and-articles" class="headerlink" title="Blogs and articles"></a>Blogs and articles</h2><ul><li><a href="/20190106/Easyhttp-by-Hadi-Hariri/">Easyhttp</a>  by Hadi Hariri</li><li><a href="/20190106/Easy-HTTP–not-Just-a-Catchy-Name/">Easy HTTP–not just a catchy name</a> by Paul Stack</li><li><del><a href="http://blogs.lessthandot.com/index.php/WebDev/ServerProgramming/servicestack-restservice-and-easyhttp" target="_blank" rel="noopener">servicestack, restservice and easyhttp</a> by Christiaan Baes</del></li><li><del><a href="http://blogs.lessthandot.com/index.php/WebDev/ServerProgramming/nancy-and-vb-net-using" target="_blank" rel="noopener">Nancy and VB.Net: Using easyhttp as our client</a> by Christiaan Baes</del></li><li><del><a href="http://blogs.lessthandot.com/index.php/WebDev/ServerProgramming/support-for-segments-in-easyhttp" target="_blank" rel="noopener">Support for segments in easyhttp</a> by Christiaan Baes</del></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to the EasyHttp wiki!&lt;/p&gt;
&lt;h2 id=&quot;Nuget&quot;&gt;&lt;a href=&quot;#Nuget&quot; class=&quot;headerlink&quot; title=&quot;Nuget&quot;&gt;&lt;/a&gt;Nuget&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://nuget
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/tags/Documentation/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Delete</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Delete/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Delete/</id>
    <published>2019-01-06T08:10:00.000Z</published>
    <updated>2019-01-06T08:40:55.870Z</updated>
    
    <content type="html"><![CDATA[<p>根据<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="noopener">W3</a>，Delete方法执行以下操作。</p><blockquote><p>DELETE方法请求源服务器删除Request-URI标识的资源。 可以通过源服务器上的人为干预（或其他方式）覆盖此方法。 即使从源服务器返回的状态代码表明操作已成功完成，也无法保证客户端已执行该操作。 但是，服务器不应该指示成功，除非在给出响应时，它打算删除资源或将其移动到不可访问的位置。</p></blockquote><p>有几种方法可以使用Easyhttp进行删除(Delete)。</p><p>这将向指定的uri发送Delete方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line"><span class="keyword">var</span> result = http.Delete(<span class="string">"http://localhost/trees?Id=1"</span>);</span><br></pre></td></tr></table></figure><p>这与此相同。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line"><span class="keyword">var</span> result = http.Delete(<span class="string">"http://localhost/trees"</span>, <span class="keyword">new</span> &#123; .Id = <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>或者对于喜欢参数为Segments的服务，您可以执行此操作。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line"><span class="keyword">var</span> result = http.Delete(<span class="string">"http://localhost/trees/1"</span>);</span><br></pre></td></tr></table></figure><p>这与此相同。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line">http.Request.ParametersAsSegments = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> result = http.Delete(<span class="string">"http://localhost/trees"</span>, <span class="keyword">new</span> &#123; .Id = <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;W3&lt;/a&gt;，Delete方法执行以下操作。&lt;/p&gt;
&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Delete" scheme="https://zfdev.com/tags/Delete/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Head</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Head/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Head/</id>
    <published>2019-01-06T08:06:00.000Z</published>
    <updated>2019-01-06T08:41:06.066Z</updated>
    
    <content type="html"><![CDATA[<p>根据<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="noopener">W3</a>，Head方法执行以下操作。</p><blockquote><p>HEAD方法与GET相同，只是服务器不能在响应中返回消息体。 响应HEAD请求的HTTP头中包含的元信息应该与响应GET请求时发送的信息相同。 该方法可用于获得关于请求所暗示的实体的元信息，而无需转移实体主体本身。 此方法通常用于测试超文本链接的有效性，可访问性和最近的修改。</p></blockquote><p>转到Get方法获取语法。 只需像这样替换Head方法。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line"><span class="keyword">var</span> result = http.Get(<span class="string">"http://localhost:55360/trees"</span>, <span class="keyword">new</span> &#123; Id = <span class="number">2</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> tree = result.DynamicBody;</span><br><span class="line">Console.WriteLine(tree.Id);</span><br><span class="line">Console.WriteLine(tree.Genus);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;W3&lt;/a&gt;，Head方法执行以下操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Head" scheme="https://zfdev.com/tags/Head/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - PutFile</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Putfile/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Putfile/</id>
    <published>2019-01-06T08:01:00.000Z</published>
    <updated>2019-01-06T08:41:13.358Z</updated>
    
    <content type="html"><![CDATA[<p>要将文件上载到Web服务器上的资源，可以使用HttpClient对象的PutFile方法。</p><p>为此，您需要传递文件所在的uri。 本地文件的路径。 以及您要上传的内容类型(contentype)，所有字符串。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> imageFile = Path.Combine(<span class="string">"Helpers"</span>, <span class="string">"test.jpg"</span>);</span><br><span class="line">httpClient.PutFile(<span class="keyword">string</span>.Format(<span class="string">"&#123;0&#125;/fileupload/test.jpg"</span>, <span class="string">"http://localhost:16000"</span>), imageFile, <span class="string">"image/jpeg"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;要将文件上载到Web服务器上的资源，可以使用HttpClient对象的PutFile方法。&lt;/p&gt;
&lt;p&gt;为此，您需要传递文件所在的uri。 本地文件的路径。 以及您要上传的内容类型(contentype)，所有字符串。&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="PutFile" scheme="https://zfdev.com/tags/PutFile/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Put</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Put/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Put/</id>
    <published>2019-01-06T07:54:00.000Z</published>
    <updated>2019-01-06T08:41:22.298Z</updated>
    
    <content type="html"><![CDATA[<p>根据 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="noopener">Spec</a></p><p>Put用于。</p><blockquote><p>PUT方法请求将所包含的实体存储在提供的Request-URI下。如果Request-URI引用已经存在的资源，则封闭的实体应该被视为驻留在源服务器上的实体的修改版本。<br>如果Request-URI未指向现有资源，并且该URI能够被请求用户代理定义为新资源，则源服务器可以使用该URI创建资源。<br>如果创建了新资源，则源服务器必须通过201（已创建）响应通知用户代理。<br>如果修改了现有资源，则应该发送200（OK）或204（No Content）响应代码以指示请求成功完成。<br>如果无法使用Request-URI创建或修改资源，则应该给出适当的错误响应，以反映问题的性质。<br>实体的接收者绝不能忽略它不理解或实现的任何Content- *（例如Content-Range）头，并且在这种情况下必须返回501（未实现）响应。</p></blockquote><p>您可以使用Put方法并使用静态，匿名或动态对象来放置服务。</p><p>让我们以<code>Tree</code>为例。</p><p>我们的<code>Tree</code>对象看起来像这样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span> ; &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">string</span> Genus &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以像这样把对象放到我们的服务上。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="keyword">new</span> Tree(); </span><br><span class="line">tree.Id = <span class="number">1</span>; </span><br><span class="line">tree.Genus = <span class="string">"Fagus"</span>;</span><br><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Put(<span class="string">"url"</span>, tree, HttpContentTypes.ApplicationJson);</span><br></pre></td></tr></table></figure><p>或者我们可以使用这样的匿名对象来完成它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Put(<span class="string">"url"</span>, <span class="keyword">new</span>&#123;Id=<span class="number">1</span>, Genus=<span class="string">"Fagus"</span>&#125;, HttpContentTypes.ApplicationJson);</span><br></pre></td></tr></table></figure><p>或者你可以Put一个动态类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="keyword">new</span> ExpandoObject(); </span><br><span class="line">tree.Id = <span class="number">1</span>; </span><br><span class="line">tree.Genus = <span class="string">"Fagus"</span>;</span><br><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Put(<span class="string">"url"</span>, tree, HttpContentTypes.ApplicationJson);</span><br></pre></td></tr></table></figure><p>您可以选择内容类型。</p><p>您还可以使用<a href="/20190106/EasyHTTP-Putfile/">PutFile</a>方法上传文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据 &lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Spec&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Put用于。&lt;/p&gt;
&lt;blockquote&gt;
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Put" scheme="https://zfdev.com/tags/Put/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Post</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Post/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Post/</id>
    <published>2019-01-06T07:43:00.000Z</published>
    <updated>2019-01-06T16:34:04.873Z</updated>
    
    <content type="html"><![CDATA[<p>根据<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="noopener">W3</a>，post方法执行以下操作</p><blockquote><p>POST方法用于请求源服务器接受请求中包含的实体作为Request-URI中Request-URI标识的资源的新下级。 POST旨在允许统一的方法来涵盖以下功能：</p><ul><li>现有资源的注释;</li><li>在公告栏，新闻组，邮件列表或类似文章组中发布消息;</li><li>向数据处理流程提供数据块，例如提交表单的结果;</li><li>通过追加操作扩展数据库。</li></ul></blockquote><p>您可以使用post方法并使用静态，匿名或动态对象提交到服务器。</p><p>让我们以<code>Tree</code>为例。</p><p>我们的<code>Tree</code>对象看起来像这样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Tree</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> Id &#123; <span class="keyword">get</span>; <span class="keyword">set</span> ; &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">string</span> Genus &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以像这样将对象提交到我们的服务器中。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="keyword">new</span> Tree(); </span><br><span class="line">tree.Id = <span class="number">1</span>; </span><br><span class="line">tree.Genus = <span class="string">"Fagus"</span>;</span><br><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Post(<span class="string">"url"</span>, tree, HttpContentTypes.ApplicationJson);</span><br></pre></td></tr></table></figure><p>或者我们可以使用这样的匿名对象来完成它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Post(<span class="string">"url"</span>, <span class="keyword">new</span>&#123;Id=<span class="number">1</span>, Genus=<span class="string">"Fagus"</span>&#125;, HttpContentTypes.ApplicationJson);</span><br></pre></td></tr></table></figure><p>或者您可以提交动态类型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tree = <span class="keyword">new</span> ExpandoObject(); </span><br><span class="line">tree.Id = <span class="number">1</span>; </span><br><span class="line">tree.Genus = <span class="string">"Fagus"</span>;</span><br><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Post(<span class="string">"url"</span>, tree, HttpContentTypes.ApplicationJson);</span><br></pre></td></tr></table></figure><p>您可以选择内容类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;W3&lt;/a&gt;，post方法执行以下操作&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Post" scheme="https://zfdev.com/tags/Post/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - GetFile</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-GetFile/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-GetFile/</id>
    <published>2019-01-06T07:38:00.000Z</published>
    <updated>2019-01-06T08:43:14.617Z</updated>
    
    <content type="html"><![CDATA[<p>您还可以通过提供要获取的文件的URI以及本地系统上的路径的文件名来获取您执行此操作的文件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line"><span class="keyword">var</span> filename = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), <span class="string">"hello.gif"</span>);</span><br><span class="line">httpClient.GetFile(<span class="string">"http://localhost:16000/hello.gif"</span>, filename);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;您还可以通过提供要获取的文件的URI以及本地系统上的路径的文件名来获取您执行此操作的文件。&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="GetFile" scheme="https://zfdev.com/tags/GetFile/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Streamresponse</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Streamresponse/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Streamresponse/</id>
    <published>2019-01-06T07:33:00.000Z</published>
    <updated>2019-01-06T08:41:41.299Z</updated>
    
    <content type="html"><![CDATA[<p>你也可以把响应体放在<code>stream</code>中</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> httpClient = <span class="keyword">new</span> HttpClient();</span><br><span class="line">httpClient.StreamResponse = <span class="literal">true</span>;</span><br><span class="line">httpClient.Get(<span class="string">"http://localhost:16000/hello"</span>);</span><br><span class="line"><span class="keyword">using</span> (<span class="keyword">var</span> stream = httpClient.Response.ResponseStream)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> count;</span><br><span class="line">   <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">var</span> buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8192</span>];</span><br><span class="line">   <span class="keyword">while</span> ((count = stream.Read(buffer, <span class="number">0</span>, buffer.Length)) &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      total += count;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>StremResponse</code>设置为<code>true</code>时，<code>RawText</code>属性将为空。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpClient.Response.RawText</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你也可以把响应体放在&lt;code&gt;stream&lt;/code&gt;中&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;sp
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Streamresponse" scheme="https://zfdev.com/tags/Streamresponse/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Get</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Get/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Get/</id>
    <published>2019-01-06T07:18:00.000Z</published>
    <updated>2019-01-06T16:35:25.923Z</updated>
    
    <content type="html"><![CDATA[<p>根据<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" target="_blank" rel="noopener">W3</a>，Get方法执行以下操作。</p><blockquote><p>GET方法意味着检索由Request-URI标识的任何信息（以实体的形式）。 如果Request-URI引用数据生成过程，则生成的数据应作为响应中的实体而不是过程的源文本返回，除非该文本恰好是过程的输出。</p></blockquote><p>有几种方法可以使用Easyhttp获取。 在下面的所有示例中，我们假设在另一侧有一个服务，它返回带有Id属性和Genus属性的<code>Tree</code>的对象。</p><p>url <code>/trees?Id=1</code> 将为我们提供一个单独的<code>Tree</code>对象，我们可以这样做。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line"><span class="keyword">var</span> result = http.Get(<span class="string">"http://localhost/trees?Id=1"</span>);</span><br><span class="line"><span class="keyword">var</span> tree = result.DynamicBody;</span><br><span class="line">Console.WriteLine(tree.Id);</span><br><span class="line">Console.WriteLine(tree.Genus);</span><br></pre></td></tr></table></figure><p>或者我们可以使用这样的匿名对象。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line"><span class="keyword">var</span> result = http.Get(<span class="string">"http://localhost/trees"</span>, <span class="keyword">new</span> &#123;Id = <span class="number">1</span>&#125; );</span><br><span class="line"><span class="keyword">var</span> tree = result.DynamicBody;</span><br><span class="line">Console.WriteLine(tree.Id);</span><br><span class="line">Console.WriteLine(tree.Genus);</span><br></pre></td></tr></table></figure><p>匿名对象将在向URL添加<code>?Id=1</code>然后执行<code>get</code>时进行转换。</p><p>我们也可以选择使用这样的动态ExpandoObject（这将产生与匿名对象相同的结果）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line"><span class="keyword">dynamic</span> parameters = <span class="keyword">new</span> ExpandoObject();</span><br><span class="line">parameters.Id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> result = http.Get(<span class="string">"http://localhost/trees"</span>, parameters );</span><br><span class="line"><span class="keyword">var</span> tree = result.DynamicBody;</span><br><span class="line">Console.WriteLine(tree.Id);</span><br><span class="line">Console.WriteLine(tree.Genus);</span><br></pre></td></tr></table></figure><p>我们的服务可能无法解释命名参数url，只能理解像<code>/trees/1</code>这样的段。</p><p>然后我们可以指示easyhttp request对象在仍然使用匿名对象的同时使我们的URL成为这样。 像这样。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line">http.Request.ParametersAsSegments = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> result = http.Get(<span class="string">"http://localhost/trees"</span>, <span class="keyword">new</span> &#123;Id = <span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> tree = result.DynamicBody;</span><br><span class="line">Console.WriteLine(tree.Id);</span><br><span class="line">Console.WriteLine(tree.Genus);</span><br></pre></td></tr></table></figure><p>以上内容与此相同</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line"><span class="keyword">var</span> result = http.Get(<span class="string">"http://localhost/trees/1"</span>);</span><br><span class="line"><span class="keyword">var</span> tree = result.DynamicBody;</span><br><span class="line">Console.WriteLine(tree.Id);</span><br><span class="line">Console.WriteLine(tree.Genus);</span><br></pre></td></tr></table></figure><p>请注意，匿名对象中属性的顺序很重要。</p><p>例如</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Get(<span class="string">"http://localhost/trees"</span>, <span class="keyword">new</span> &#123;Id = <span class="number">1</span>, Name = <span class="string">"test"</span>&#125;);</span><br></pre></td></tr></table></figure><p>将生成此网址<br><code>http://localhost/trees/1/test</code></p><p>而以下代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Get(<span class="string">"http://localhost/trees"</span>, <span class="keyword">new</span> &#123;Name = <span class="string">"test"</span>, Id = <span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure><p>会生成</p><p><code>http://localhost/trees/test/1</code></p><p>我们当然也可以使用pocos（也支持ExpandoObjects）作为参数，而不是使用匿名对象。</p><p>如果您的服务以对象列表响应，那么您可以像这样读取它们。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br><span class="line"><span class="keyword">var</span> trees = http.Get(<span class="string">"http://localhost:55360/trees"</span>);</span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">var</span> t <span class="keyword">in</span> trees.DynamicBody)</span><br><span class="line">&#123;</span><br><span class="line">   Console.WriteLine(t.Id);</span><br><span class="line">   Console.WriteLine(t.Genus);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以使用 <a href="/20190106/EasyHTTP-Streamresponse/">stream the response</a>.</p><p>或者 <a href="/20190106/EasyHTTP-GetFile/">get a file</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据&lt;a href=&quot;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;W3&lt;/a&gt;，Get方法执行以下操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Get" scheme="https://zfdev.com/tags/Get/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Httpstatuscode</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Httpstatuscode/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Httpstatuscode/</id>
    <published>2019-01-06T06:27:00.000Z</published>
    <updated>2019-01-06T08:42:38.260Z</updated>
    
    <content type="html"><![CDATA[<p>包含为HTTP定义的状态代码的值。</p><h2 id="Continue-100"><a href="#Continue-100" class="headerlink" title="Continue = 100"></a>Continue = 100</h2><p>等效于HTTP状态100.<br><code>System.Net.HttpStatusCode.Continue</code>表示<br>客户端可以继续其请求。</p><h2 id="SwitchingProtocols-101"><a href="#SwitchingProtocols-101" class="headerlink" title="SwitchingProtocols = 101"></a>SwitchingProtocols = 101</h2><p>等效于HTTP状态101.<br><code>System.Net.HttpStatusCode.SwitchingProtocols</code><br>表示正在更改协议版本或协议。</p><h2 id="OK-200"><a href="#OK-200" class="headerlink" title="OK = 200"></a>OK = 200</h2><p>相当于HTTP状态200.<br><code>System.Net.HttpStatusCode.OK</code>表示请求成功，请求的信息在响应中。<br>这是最常见的状态代码。</p><h2 id="Created-201"><a href="#Created-201" class="headerlink" title="Created = 201"></a>Created = 201</h2><p>等效于HTTP状态201.<br><code>System.Net.HttpStatusCode.Created</code>表示请求导致在发送响应之前创建新资源。</p><h2 id="Accepted-202"><a href="#Accepted-202" class="headerlink" title="Accepted = 202"></a>Accepted = 202</h2><p>等效于HTTP状态202.<br><code>System.Net.HttpStatusCode.Accepted</code>表示<br>该请求已被接受进一步处理。</p><h2 id="NonAuthoritativeInformation-203"><a href="#NonAuthoritativeInformation-203" class="headerlink" title="NonAuthoritativeInformation = 203"></a>NonAuthoritativeInformation = 203</h2><p>等效于HTTP状态203.<br><code>System.Net.HttpStatusCode.NonAuthoritativeInformation</code> 表示返回的元信息来自原始服务器的缓存副本，因此可能是不正确的。</p><h2 id="NoContent-204"><a href="#NoContent-204" class="headerlink" title="NoContent = 204"></a>NoContent = 204</h2><p>等效于HTTP状态204.<br><code>System.Net.HttpStatusCode.NoContent</code>表示请求已成功处理并且响应内容为空。</p><h2 id="ResetContent-205"><a href="#ResetContent-205" class="headerlink" title="ResetContent = 205"></a>ResetContent = 205</h2><p>等效于HTTP状态205.<br><code>System.Net.HttpStatusCode.ResetContent</code>表示客户端应重置（不重新加载）当前资源。</p><h2 id="PartialContent-206"><a href="#PartialContent-206" class="headerlink" title="PartialContent = 206"></a>PartialContent = 206</h2><p>等效于HTTP状态206.<br><code>System.Net.HttpStatusCode.PartialContent</code>表示响应是包含字节范围的GET请求所请求的部分响应。</p><h2 id="MultipleChoices-300"><a href="#MultipleChoices-300" class="headerlink" title="MultipleChoices = 300"></a>MultipleChoices = 300</h2><p>等效于HTTP状态300.<br><code>System.Net.HttpStatusCode.MultipleChoices</code><br>表示所请求的信息具有多个表示。<br>默认操作是将此状态视为重定向，并按照与此响应关联的<code>Location</code>标头的内容进行操作。</p><h2 id="Ambiguous-300"><a href="#Ambiguous-300" class="headerlink" title="Ambiguous = 300"></a>Ambiguous = 300</h2><p>等效于HTTP状态300.<br><code>System.Net.HttpStatusCode.Ambiguous</code><br>表示所请求的信息具有多个表示。<br>默认操作是将此状态视为重定向，并按照与此响应关联的<code>Location</code>标头的内容进行操作。</p><h2 id="MovedPermanently-301"><a href="#MovedPermanently-301" class="headerlink" title="MovedPermanently = 301"></a>MovedPermanently = 301</h2><p>等效于HTTP状态301.<br><code>System.Net.HttpStatusCode.MovedPermanently</code>表示所请求的信息已移至<code>Location头</code>中指定的URI。<br>收到此状态时的默认操作是遵循与响应关联的Location标头。</p><h2 id="Moved-301"><a href="#Moved-301" class="headerlink" title="Moved = 301"></a>Moved = 301</h2><p>等效于HTTP状态301.<br><code>System.Net.HttpStatusCode.Moved</code>表示所请求的信息已移至<code>Location</code>头中指定的URI。<br>收到此状态时的默认操作是遵循与响应关联的<code>Location</code>标头。<br>当原始请求方法是<code>POST</code>时，重定向的请求将使用<code>GET</code>方法。</p><h2 id="Found-302"><a href="#Found-302" class="headerlink" title="Found = 302"></a>Found = 302</h2><p>等效于HTTP状态302.<br><code>System.Net.HttpStatusCode.Found</code>表示所请求的信息位于<code>Location</code>标头中指定的<code>URI</code>。<br>收到此状态时的默认操作是遵循与响应关联的<code>Location</code>标头。<br>当原始请求方法是<code>POST</code>时，重定向的请求将使用<code>GET</code>方法。</p><h2 id="Redirect-302"><a href="#Redirect-302" class="headerlink" title="Redirect = 302"></a>Redirect = 302</h2><p>等效于HTTP状态302.<br><code>System.Net.HttpStatusCode.Redirect</code>表示所请求的信息位于<code>Location头</code>中指定的<code>URI</code>。<br>收到此状态时的默认操作是遵循与响应关联的<code>Location</code>标头。<br>当原始请求方法是<code>POST</code>时，重定向的请求将使用<code>GET</code>方法。</p><h2 id="SeeOther-303"><a href="#SeeOther-303" class="headerlink" title="SeeOther = 303"></a>SeeOther = 303</h2><p>等效于HTTP状态303.<br><code>System.Net.HttpStatusCode.SeeOther</code>自动将客户端重定向到作为<code>POST</code>结果的<code>Location</code>头中指定的<code>URI</code>。<br>对<code>Location</code>标头指定的资源的请求将使用<code>GET</code>进行。</p><h2 id="RedirectMethod-303"><a href="#RedirectMethod-303" class="headerlink" title="RedirectMethod = 303"></a>RedirectMethod = 303</h2><p>等效于HTTP状态303.<br>作为POST的结果，<code>System.Net.HttpStatusCode.RedirectMethod</code>自动将客户端重定向到<code>Location</code>头中指定的<code>URI</code>。对<code>Location</code>标头指定的资源的请求将使用<code>GET</code>进行。</p><h2 id="NotModified-304"><a href="#NotModified-304" class="headerlink" title="NotModified = 304"></a>NotModified = 304</h2><p>等效于HTTP状态304. <code>System.Net.HttpStatusCode.NotModified</code>表示客户端的缓存副本是最新的。资源的内容不会传输。</p><h2 id="UseProxy-305"><a href="#UseProxy-305" class="headerlink" title="UseProxy = 305"></a>UseProxy = 305</h2><p>等效于HTTP状态305.<br><code>System.Net.HttpStatusCode.UseProxy</code>表示请求应使用<code>Location</code>头中指定的<code>URI</code>处的代理服务器。</p><h2 id="Unused-306"><a href="#Unused-306" class="headerlink" title="Unused = 306"></a>Unused = 306</h2><p>等效于HTTP状态306.<br><code>System.Net.HttpStatusCode.Unused</code>是 <code>HTTP/1.1</code> 规范的建议扩展，未完全指定。</p><h2 id="TemporaryRedirect-307"><a href="#TemporaryRedirect-307" class="headerlink" title="TemporaryRedirect = 307"></a>TemporaryRedirect = 307</h2><p>等效于HTTP状态307.<br><code>System.Net.HttpStatusCode.TemporaryRedirect</code>指示请求信息位于<code>Location</code>头中指定的<code>URI</code>。<br>收到此状态时的默认操作是遵循与响应关联的<code>Location</code>标头。<br>当原始请求方法是<code>POST</code>时，重定向的请求也将使用<code>POST</code>方法。</p><h2 id="RedirectKeepVerb-307"><a href="#RedirectKeepVerb-307" class="headerlink" title="RedirectKeepVerb = 307"></a>RedirectKeepVerb = 307</h2><p>等效于HTTP状态307.<br><code>System.Net.HttpStatusCode.RedirectKeepVerb</code>指示请求信息位于<code>Location</code>头中指定的<code>URI</code>。<br>收到此状态时的默认操作是遵循与响应关联的<code>Location</code>标头。<br>当原始请求方法是<code>POST</code>时，重定向的请求也将使用<code>POST</code>方法。</p><h2 id="BadRequest-400"><a href="#BadRequest-400" class="headerlink" title="BadRequest = 400"></a>BadRequest = 400</h2><p>等效于HTTP状态400.<br><code>System.Net.HttpStatusCode.BadRequest</code>表示服务器无法理解该请求。<br>如果没有其他错误适用，或者确切错误未知或没有自己的错误代码，则会发送<code>System.Net.HttpStatusCode.BadRequest</code>。</p><h2 id="Unauthorized-401"><a href="#Unauthorized-401" class="headerlink" title="Unauthorized = 401"></a>Unauthorized = 401</h2><p>等效于HTTP状态401.<br><code>System.Net.HttpStatusCode.Unauthorized</code>指示所请求的资源需要身份验证。<br><code>WWW-Authenticate</code>标头包含有关如何执行身份验证的详细信息。</p><h2 id="PaymentRequired-402"><a href="#PaymentRequired-402" class="headerlink" title="PaymentRequired = 402"></a>PaymentRequired = 402</h2><p>等效于HTTP状态402.<br>保留<code>System.Net.HttpStatusCode.PaymentRequired</code>以供将来使用。</p><h2 id="Forbidden-403"><a href="#Forbidden-403" class="headerlink" title="Forbidden = 403"></a>Forbidden = 403</h2><p>等效于HTTP状态403.<br><code>System.Net.HttpStatusCode.Forbidden</code>表示服务器拒绝满足请求。</p><h2 id="NotFound-404"><a href="#NotFound-404" class="headerlink" title="NotFound = 404"></a>NotFound = 404</h2><p>等效于HTTP状态404.<br><code>System.Net.HttpStatusCode.NotFound</code>指示服务器上不存在所请求的资源。</p><h2 id="MethodNotAllowed-405"><a href="#MethodNotAllowed-405" class="headerlink" title="MethodNotAllowed = 405"></a>MethodNotAllowed = 405</h2><p>等效于HTTP状态405.<br><code>System.Net.HttpStatusCode.MethodNotAllowed</code>指示在请求的资源上不允许请求方法（<code>POST</code>或<code>GET</code>）。</p><h2 id="NotAcceptable-406"><a href="#NotAcceptable-406" class="headerlink" title="NotAcceptable = 406"></a>NotAcceptable = 406</h2><p>等效于HTTP状态406.<br><code>System.Net.HttpStatusCode.NotAcceptable</code>指示客户端已使用<code>Accept</code>标头指示它不接受资源的任何可用表示。</p><h2 id="ProxyAuthenticationRequired-407"><a href="#ProxyAuthenticationRequired-407" class="headerlink" title="ProxyAuthenticationRequired = 407"></a>ProxyAuthenticationRequired = 407</h2><p>等效于HTTP状态407.<br><code>System.Net.HttpStatusCode.ProxyAuthenticationRequired</code>指示所请求的代理需要身份验证。<br><code>Proxy-authenticate</code>标头包含有关如何执行身份验证的详细信息。</p><h2 id="RequestTimeout-408"><a href="#RequestTimeout-408" class="headerlink" title="RequestTimeout = 408"></a>RequestTimeout = 408</h2><p>等效于HTTP状态408.<br><code>System.Net.HttpStatusCode.RequestTimeout</code>指示客户端在服务器期望请求的时间内未发送请求。</p><h2 id="Conflict-409"><a href="#Conflict-409" class="headerlink" title="Conflict = 409"></a>Conflict = 409</h2><p>等效于HTTP状态409.<br><code>System.Net.HttpStatusCode.Conflict</code>表示由于服务器上的冲突而无法执行请求。</p><h2 id="Gone-410"><a href="#Gone-410" class="headerlink" title="Gone = 410"></a>Gone = 410</h2><p>等效于HTTP状态410.<br><code>System.Net.HttpStatusCode.Gone</code>表示请求的资源不再可用。</p><h2 id="LengthRequired-411"><a href="#LengthRequired-411" class="headerlink" title="LengthRequired = 411"></a>LengthRequired = 411</h2><p>等效于HTTP状态411.<br><code>System.Net.HttpStatusCode.LengthRequired</code>指示缺少所需的<code>Content-length</code>标头。</p><h2 id="PreconditionFailed-412"><a href="#PreconditionFailed-412" class="headerlink" title="PreconditionFailed = 412"></a>PreconditionFailed = 412</h2><p>等效于HTTP状态412.<br><code>System.Net.HttpStatusCode.PreconditionFailed</code>指示为此请求设置的条件失败，并且无法执行请求。条件使用条件请求标头设置，如<code>If-Match</code>，<code>If-None-Match</code>或<code>If-Unmodified-Since</code>。</p><h2 id="RequestEntityTooLarge-413"><a href="#RequestEntityTooLarge-413" class="headerlink" title="RequestEntityTooLarge = 413"></a>RequestEntityTooLarge = 413</h2><p>等效于HTTP状态413.<br><code>System.Net.HttpStatusCode.RequestEntityTooLarge</code>指示请求对于服务器来说太大而无法处理。</p><h2 id="RequestUriTooLong-414"><a href="#RequestUriTooLong-414" class="headerlink" title="RequestUriTooLong = 414"></a>RequestUriTooLong = 414</h2><p>等效于HTTP状态414.<br><code>System.Net.HttpStatusCode.RequestUriTooLong</code>表示<code>URI</code>太长。</p><h2 id="UnsupportedMediaType-415"><a href="#UnsupportedMediaType-415" class="headerlink" title="UnsupportedMediaType = 415"></a>UnsupportedMediaType = 415</h2><p>等效于HTTP状态415.<br><code>System.Net.HttpStatusCode.UnsupportedMediaType</code>指示请求是不受支持的类型。</p><h2 id="RequestedRangeNotSatisfiable-416"><a href="#RequestedRangeNotSatisfiable-416" class="headerlink" title="RequestedRangeNotSatisfiable = 416"></a>RequestedRangeNotSatisfiable = 416</h2><p>等效于HTTP状态416.<br><code>System.Net.HttpStatusCode.RequestedRangeNotSatisfiable</code>指示无法返回从资源请求的数据范围，因为范围的开头位于资源的开头之前，或者范围的结尾位于资源的结束。</p><h2 id="ExpectationFailed-417"><a href="#ExpectationFailed-417" class="headerlink" title="ExpectationFailed = 417"></a>ExpectationFailed = 417</h2><p>等效于HTTP状态417.<br><code>System.Net.HttpStatusCode.ExpectationFailed</code>指示服务器无法满足<code>Expect</code>标头中给出的期望。</p><h2 id="InternalServerError-500"><a href="#InternalServerError-500" class="headerlink" title="InternalServerError = 500"></a>InternalServerError = 500</h2><p>等效于HTTP状态500.<br><code>System.Net.HttpStatusCode.InternalServerError</code>指示服务器上发生了一般错误。</p><h2 id="NotImplemented-501"><a href="#NotImplemented-501" class="headerlink" title="NotImplemented = 501"></a>NotImplemented = 501</h2><p>等效于HTTP状态501.<br><code>System.Net.HttpStatusCode.NotImplemented</code>指示服务器不支持所请求的功能。</p><h2 id="BadGateway-502"><a href="#BadGateway-502" class="headerlink" title="BadGateway = 502"></a>BadGateway = 502</h2><p>等效于HTTP状态502.<br><code>System.Net.HttpStatusCode.BadGateway</code>指示中间代理服务器从另一个代理或源服务器收到错误响应。</p><h2 id="ServiceUnavailable-503"><a href="#ServiceUnavailable-503" class="headerlink" title="ServiceUnavailable = 503"></a>ServiceUnavailable = 503</h2><p>等效于HTTP状态503.<br><code>System.Net.HttpStatusCode.ServiceUnavailable</code>指示服务器暂时不可用，通常是由于高负载或维护。</p><h2 id="GatewayTimeout-504"><a href="#GatewayTimeout-504" class="headerlink" title="GatewayTimeout = 504"></a>GatewayTimeout = 504</h2><p>等效于HTTP状态504.<br><code>System.Net.HttpStatusCode.GatewayTimeout</code>指示中间代理服务器在等待来自另一个代理或源服务器的响应时超时。</p><h2 id="HttpVersionNotSupported-505"><a href="#HttpVersionNotSupported-505" class="headerlink" title="HttpVersionNotSupported = 505"></a>HttpVersionNotSupported = 505</h2><p>等效于HTTP状态505.<br><code>System.Net.HttpStatusCode.HttpVersionNotSupported</code>指示服务器不支持所请求的<code>HTTP</code>版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包含为HTTP定义的状态代码的值。&lt;/p&gt;
&lt;h2 id=&quot;Continue-100&quot;&gt;&lt;a href=&quot;#Continue-100&quot; class=&quot;headerlink&quot; title=&quot;Continue = 100&quot;&gt;&lt;/a&gt;Continue = 100&lt;/h2&gt;&lt;p&gt;等
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="HTTP" scheme="https://zfdev.com/tags/HTTP/"/>
    
      <category term="HttpStatuscode" scheme="https://zfdev.com/tags/HttpStatuscode/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Response</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Response/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Response/</id>
    <published>2019-01-06T06:10:00.000Z</published>
    <updated>2019-01-06T08:41:52.403Z</updated>
    
    <content type="html"><![CDATA[<p>response对象将包含请求发出后从服务器返回的数据。</p><h2 id="ContentType"><a href="#ContentType" class="headerlink" title="ContentType"></a>ContentType</h2><p>包含用于此响应的内容类型(contentype)的只读属性。 字符串类型。</p><h2 id="StatusCode"><a href="#StatusCode" class="headerlink" title="StatusCode"></a>StatusCode</h2><p>包含此响应返回的<code>状态码</code>的只读属性。 <a href="/20190106/EasyHTTP-Httpstatuscode/">HttpStatusCode</a>类型.</p><h2 id="StatusDescription"><a href="#StatusDescription" class="headerlink" title="StatusDescription"></a>StatusDescription</h2><p>包含用于此响应的<code>状态描述</code>的只读属性。</p><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>包含用于此响应的<code>cookies</code>的只读属性。</p><h2 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h2><p>包含此<code>响应时间</code>的只读属性。</p><h2 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h2><p>包含用于此响应的<code>httpmethods</code>的只读属性。</p><h2 id="CacheControl"><a href="#CacheControl" class="headerlink" title="CacheControl"></a>CacheControl</h2><p>包含用于此响应的<code>缓存控制</code>的只读属性。</p><h2 id="ContentEncoding"><a href="#ContentEncoding" class="headerlink" title="ContentEncoding"></a>ContentEncoding</h2><p>包含用于此响应的<code>内容编码</code>的只读属性。</p><h2 id="ContentLanguage"><a href="#ContentLanguage" class="headerlink" title="ContentLanguage"></a>ContentLanguage</h2><p>包含用于此响应的<code>内容语言</code>的只读属性。</p><h2 id="ContentLength"><a href="#ContentLength" class="headerlink" title="ContentLength"></a>ContentLength</h2><p>包含用于此响应的<code>内容长度</code>的只读属性。</p><h2 id="ContentLocation"><a href="#ContentLocation" class="headerlink" title="ContentLocation"></a>ContentLocation</h2><p>包含用于此响应的<code>当前位置</code>的只读属性。</p><h2 id="ContentDisposition"><a href="#ContentDisposition" class="headerlink" title="ContentDisposition"></a>ContentDisposition</h2><p>包含用于此响应的<code>内容处理</code>的只读属性。</p><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>包含用于此响应的<code>日期</code>的只读属性。</p><h2 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h2><p>包含用于此响应的<code>实体标签(Entity Tag)</code>的只读属性。</p><h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>包含用于此响应的<code>过期</code>的只读属性。</p><h2 id="LastModified"><a href="#LastModified" class="headerlink" title="LastModified"></a>LastModified</h2><p>包含用于此响应的<code>上次更改时间</code>的只读属性。</p><h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><p>包含用于此响应的<code>位置</code>的只读属性。</p><h2 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h2><p>包含用于此响应的<code>pragma</code>的只读属性。</p><h2 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h2><p>包含用于此响应的<code>服务器</code>的只读属性。</p><h2 id="RawHeaders"><a href="#RawHeaders" class="headerlink" title="RawHeaders"></a>RawHeaders</h2><p>包含用于此响应的<code>原始头信息</code>的只读属性。</p><h2 id="ResponseStream"><a href="#ResponseStream" class="headerlink" title="ResponseStream"></a>ResponseStream</h2><p>包含此响应的<code>响应流</code>的只读属性。</p><h2 id="DynamicBody"><a href="#DynamicBody" class="headerlink" title="DynamicBody"></a>DynamicBody</h2><h2 id="RawText"><a href="#RawText" class="headerlink" title="RawText"></a>RawText</h2><h2 id="StaticBody-string-overrideContentType-null"><a href="#StaticBody-string-overrideContentType-null" class="headerlink" title="StaticBody(string overrideContentType = null)"></a>StaticBody<t>(string overrideContentType = null)</t></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;response对象将包含请求发出后从服务器返回的数据。&lt;/p&gt;
&lt;h2 id=&quot;ContentType&quot;&gt;&lt;a href=&quot;#ContentType&quot; class=&quot;headerlink&quot; title=&quot;ContentType&quot;&gt;&lt;/a&gt;ContentType&lt;/h2&gt;&lt;
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Response" scheme="https://zfdev.com/tags/Response/"/>
    
      <category term="HTTP" scheme="https://zfdev.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Request</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Request/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Request/</id>
    <published>2019-01-06T06:00:00.000Z</published>
    <updated>2019-01-06T08:42:01.139Z</updated>
    
    <content type="html"><![CDATA[<p>request用于发送数据到服务器，可以根据自己的喜好进行配置。</p><h2 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h2><p><code>accept</code>属性允许您从响应中设置所需的超媒体类型。 该字段是一个字符串，但为方便起见，还有一些常量可以在<code>HttpContentypes</code>类中使用。</p><p>你这样使用它。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Request.Accept = HttpContentTypes.ApplicationJson;</span><br></pre></td></tr></table></figure><p>或者你也可以写。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http.Request.Accept = <span class="string">"application/json"</span>;</span><br></pre></td></tr></table></figure><p>这将要求响应将其内容编码为JSON。</p><p>这是<code>HttpContenttypes</code>中的另一种类型。</p><ul><li>MultiPartFormData = “multipart/form-data”;</li><li>TextPlain = “text/plain”;</li><li>TextHtml = “text/html”;</li><li>TextCsv = “text/csv”;</li><li>ApplicationJson = “application/json”;</li><li>ApplicationXml = “application/xml”;</li><li>ApplicationXWwwFormUrlEncoded = “application/x-www-form-urlencoded”;</li><li>ApplicationOctetStream = “application/octet-stream”;</li></ul><h2 id="AcceptCharSet"><a href="#AcceptCharSet" class="headerlink" title="AcceptCharSet"></a>AcceptCharSet</h2><h2 id="AcceptEncoding"><a href="#AcceptEncoding" class="headerlink" title="AcceptEncoding"></a>AcceptEncoding</h2><h2 id="AcceptLanguage"><a href="#AcceptLanguage" class="headerlink" title="AcceptLanguage"></a>AcceptLanguage</h2><h2 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h2><h2 id="ClientCertificates"><a href="#ClientCertificates" class="headerlink" title="ClientCertificates"></a>ClientCertificates</h2><h2 id="ContentLength"><a href="#ContentLength" class="headerlink" title="ContentLength"></a>ContentLength</h2><h2 id="ContentType"><a href="#ContentType" class="headerlink" title="ContentType"></a>ContentType</h2><h2 id="ContentEncoding"><a href="#ContentEncoding" class="headerlink" title="ContentEncoding"></a>ContentEncoding</h2><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><h2 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h2><h2 id="From"><a href="#From" class="headerlink" title="From"></a>From</h2><h2 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h2><h2 id="IfMatch"><a href="#IfMatch" class="headerlink" title="IfMatch"></a>IfMatch</h2><h2 id="IfModifiedSince"><a href="#IfModifiedSince" class="headerlink" title="IfModifiedSince"></a>IfModifiedSince</h2><h2 id="IfRange"><a href="#IfRange" class="headerlink" title="IfRange"></a>IfRange</h2><h2 id="MaxForwards"><a href="#MaxForwards" class="headerlink" title="MaxForwards"></a>MaxForwards</h2><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><h2 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h2><h2 id="UserAgent"><a href="#UserAgent" class="headerlink" title="UserAgent"></a>UserAgent</h2><h2 id="RawHeaders"><a href="#RawHeaders" class="headerlink" title="RawHeaders"></a>RawHeaders</h2><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>允许您获取并设置<code>Request</code>将使用的<code>HttpMethod</code>。</p><p>此属性是名为HttpMethod的枚举，它包含以下方法。</p><ul><li>HEAD</li><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li><li>OPTIONS</li><li>PATCH</li></ul><p>此属性也将根据您在<a href="/20190106/EasyHTTP-Httpclient/">HttpClient</a>上使用的方法进行设置</p><h2 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h2><h2 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h2><h2 id="PutFilename"><a href="#PutFilename" class="headerlink" title="PutFilename"></a>PutFilename</h2><h2 id="MultiPartFormData"><a href="#MultiPartFormData" class="headerlink" title="MultiPartFormData"></a>MultiPartFormData</h2><h2 id="MultiPartFileData"><a href="#MultiPartFileData" class="headerlink" title="MultiPartFileData"></a>MultiPartFileData</h2><h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><h2 id="ParametersAsSegments"><a href="#ParametersAsSegments" class="headerlink" title="ParametersAsSegments"></a>ParametersAsSegments</h2><p>有关使用它的原因和方式的详细信息，请参阅<a href="/20190106/EasyHTTP-Get/">Get</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;request用于发送数据到服务器，可以根据自己的喜好进行配置。&lt;/p&gt;
&lt;h2 id=&quot;Accept&quot;&gt;&lt;a href=&quot;#Accept&quot; class=&quot;headerlink&quot; title=&quot;Accept&quot;&gt;&lt;/a&gt;Accept&lt;/h2&gt;&lt;p&gt;&lt;code&gt;accept&lt;/
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Request" scheme="https://zfdev.com/tags/Request/"/>
    
  </entry>
  
  <entry>
    <title>EasyHTTP - Httpclient</title>
    <link href="https://zfdev.com/20190106/EasyHTTP-Httpclient/"/>
    <id>https://zfdev.com/20190106/EasyHTTP-Httpclient/</id>
    <published>2019-01-06T05:48:00.000Z</published>
    <updated>2019-01-06T08:42:11.420Z</updated>
    
    <content type="html"><![CDATA[<p>You can make a HttpClient like this.<br>你可以这样创建一个HttpClient。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient();</span><br></pre></td></tr></table></figure><p>The empty constructor means that you will have to provide a url for each and every call (Get, Post, …)</p><p>Or like this</p><p>空构造函数意味着您必须为每个调用提供一个URL（Get，Post，…）</p><p>或者像这样</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient(<span class="string">"http://localhost"</span>);</span><br></pre></td></tr></table></figure><p>Here we instantiated the client with a baseuri. For all the calls you make with this client the baseuri will be prefixed to your uri.</p><p>So this.</p><p>在这里，我们使用baseuri实例化客户端。 对于您使用此客户端发出的所有请求，baseuri将以uri为前缀。</p><p>如：<br><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient(<span class="string">"http://localhost"</span>);</span><br><span class="line"><span class="keyword">var</span> result = http.Get(<span class="string">"/trees"</span>);</span><br></pre></td></tr></table></figure></p><p>is actually the same as writing.</p><p>上面的写法与下面是一样的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> HttpClient(<span class="string">"http://localhost"</span>);</span><br><span class="line"><span class="keyword">var</span> result = http.Get(<span class="string">"http://localhost/trees"</span>);</span><br></pre></td></tr></table></figure><p>The httpclient object contains the <a href="/20190106/EasyHTTP-Request/">Request</a> and <a href="/20190106/EasyHTTP-Response/">Response</a> object. You can set properties on those objects to control the request and response. </p><p>The httpclient also contains the following http verbs which you can use.</p><p>httpclient对象包含Request和Response对象。 您可以在这些对象上设置属性以控制请求和响应。</p><p>httpclient还包含您可以使用的以下http方法。</p><ul><li><a href="/20190106/EasyHTTP-Get/">Get</a></li><li><a href="/20190106/EasyHTTP-Post/">Post</a></li><li><a href="/20190106/EasyHTTP-Put/">Put</a></li><li>Patch</li><li>Options</li><li><a href="/20190106/EasyHTTP-Head/">Head</a></li><li><a href="/20190106/EasyHTTP-Delete/">Delete</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;You can make a HttpClient like this.&lt;br&gt;你可以这样创建一个HttpClient。&lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;spa
      
    
    </summary>
    
      <category term="C#" scheme="https://zfdev.com/categories/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/categories/C/EasyHTTP/"/>
    
      <category term="Documentation" scheme="https://zfdev.com/categories/C/EasyHTTP/Documentation/"/>
    
    
      <category term="C#" scheme="https://zfdev.com/tags/C/"/>
    
      <category term="EasyHTTP" scheme="https://zfdev.com/tags/EasyHTTP/"/>
    
      <category term="Httpclient" scheme="https://zfdev.com/tags/Httpclient/"/>
    
  </entry>
  
  <entry>
    <title>Win7 重装日志 软件</title>
    <link href="https://zfdev.com/20190104/Win7-%E9%87%8D%E8%A3%85%E6%97%A5%E5%BF%97/"/>
    <id>https://zfdev.com/20190104/Win7-重装日志/</id>
    <published>2019-01-04T10:49:00.000Z</published>
    <updated>2019-01-06T10:38:00.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ol><li><p>7-zip    (<a href="https://www.7-zip.org/" target="_blank" rel="noopener">https://www.7-zip.org/</a>)</p></li><li><p>输入法</p><ul><li>搜狗输入法 (<a href="https://pinyin.sogou.com/" target="_blank" rel="noopener">https://pinyin.sogou.com/</a>) / <a href="http://www.xingkbjm.com/ime.html" target="_blank" rel="noopener">星空修改版</a></li><li>RIME(小狼毫)    (<a href="https://rime.im/download/" target="_blank" rel="noopener">https://rime.im/download/</a>)</li></ul></li><li><p>浏览器</p><ul><li>Chrome    (<a href="https://www.google.cn/chrome/" target="_blank" rel="noopener">https://www.google.cn/chrome/</a>)</li><li>Chrome 开发者版    (<a href="https://www.google.cn/chrome/dev" target="_blank" rel="noopener">https://www.google.cn/chrome/dev</a>)</li><li>360极速浏览器    <a href="https://browser.360.cn/ee/" target="_blank" rel="noopener">官方下载</a></li></ul></li><li><p>浏览器插件</p><ul><li>SwitchyOmega (<a href="https://github.com/FelisCatus/SwitchyOmega/releases" target="_blank" rel="noopener">https://github.com/FelisCatus/SwitchyOmega/releases</a>)</li></ul></li><li><p>Fiddler  (<a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">https://www.telerik.com/download/fiddler</a>)</p></li><li><p>Python</p><ul><li>官方版本    (<a href="https://www.python.org/downloads/" target="_blank" rel="noopener">https://www.python.org/downloads/</a>)</li><li>AnaConda  (<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">https://www.anaconda.com/download/</a>)</li></ul></li><li><p>PyChram (<a href="http://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">http://www.jetbrains.com/pycharm/download/</a>)</p></li><li><p>Everything (<a href="http://www.voidtools.com/downloads/" target="_blank" rel="noopener">http://www.voidtools.com/downloads/</a>)</p><ul><li>语言包 (<a href="http://www.voidtools.com/Everything.lng.zip" target="_blank" rel="noopener">http://www.voidtools.com/Everything.lng.zip</a>)</li></ul></li><li><p>Listary (<a href="https://www.listary.com/download" target="_blank" rel="noopener">https://www.listary.com/download</a>)</p></li><li><p>f.lux (<a href="https://justgetflux.com/" target="_blank" rel="noopener">https://justgetflux.com/</a>)</p></li><li><p>Sourcetree (<a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">https://www.sourcetreeapp.com/</a>)</p><ul><li><a href="https://www.cnblogs.com/lucio110/p/8192792.html" target="_blank" rel="noopener">跳过注册</a></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;软件安装&quot;&gt;&lt;a href=&quot;#软件安装&quot; class=&quot;headerlink&quot; title=&quot;软件安装&quot;&gt;&lt;/a&gt;软件安装&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;7-zip    (&lt;a href=&quot;https://www.7-zip.org/&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="Other" scheme="https://zfdev.com/categories/Other/"/>
    
    
      <category term="win7" scheme="https://zfdev.com/tags/win7/"/>
    
  </entry>
  
</feed>
