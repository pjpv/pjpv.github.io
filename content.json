{"meta":{"title":"Blog","subtitle":"博客","description":"个人博客","author":"Greendev","url":"https://dxx.fun"},"pages":[{"title":"About","date":"2018-11-02T08:27:02.487Z","updated":"2018-11-02T08:27:02.487Z","comments":true,"path":"about/index.html","permalink":"https://dxx.fun/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-11-02T08:27:02.487Z","updated":"2018-11-02T08:27:02.487Z","comments":true,"path":"categories/index.html","permalink":"https://dxx.fun/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-02T08:27:02.487Z","updated":"2018-11-02T08:27:02.487Z","comments":true,"path":"tags/index.html","permalink":"https://dxx.fun/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PHP - 基础 - 流程控制","slug":"PHP-基础-流程控制","date":"2018-11-14T07:15:00.000Z","updated":"2018-11-14T07:34:20.196Z","comments":true,"path":"20181114/PHP-基础-流程控制/","link":"","permalink":"https://dxx.fun/20181114/PHP-基础-流程控制/","excerpt":"","text":"PHP的遍历数组的三种方式及各自区别 延伸：分支结构 PHP的遍历数组的三种方式及各自区别三种方式 使用for循环 使用foreach循环 使用while、list()、each()组合循环 区别 for 循环只能遍历索引数组； foreach 可以遍历索引和关联数组，联合使用list()，each()和while 循环同样可以遍历索引和关联数组； while、list()、each()组合不会 reset()； foreach遍历会对数组进行 reset() 操作； 分支结构if….elseif 在elseif语句中只能有一个表达式为 true ，即在elseif语句中只能有一个语句块被执行，多个elseif从句是排斥关系。 使用elseif语句有一个基本原则，总吧优先范围小的条件放在前面处理。12345678910&lt;?php $a = 5; if($a &lt; 3)&#123; &#125;elseif($a &gt; 3)&#123; &#125;else&#123; // $a == 3; &#125;?&gt; switch…case… 和 if 不同的是， switch后面的控制表达式的数据类型只能是整形、浮点类型或字符串 1234567891011121314&lt;?php $a = 5; switch($a)&#123; case 1; echo 'a = 1'; break; case 2: echo 'a = 2'; break; default: echo 'a 不是预期的数字'; break; &#125;?&gt; continue 语句作用到 switch 的作用类似于 break 跳出 switch 外的循环，可以使用 continue 2 效率 如果条件比一个简单的比较要复杂得多或者在一个很多次的循环中，那么使用 switch 语句可能会快一些 重点 理解循环内部机制，更易于记忆 foreach 的 reset 特性，分支结构中理解了 switch…case 的执行步骤也就不难理解为什么效率高了。 问题 PHP中如何优化多个if…elseif语句的情况？ 可能性较大的尽量往前挪； 如果判断的是一个比较复杂的结构，且判断的值是整型、浮点或字符串可以使用 switch…case","categories":[{"name":"PHP","slug":"PHP","permalink":"https://dxx.fun/categories/PHP/"},{"name":"基础","slug":"PHP/基础","permalink":"https://dxx.fun/categories/PHP/基础/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://dxx.fun/tags/PHP/"},{"name":"基础","slug":"基础","permalink":"https://dxx.fun/tags/基础/"},{"name":"流程控制","slug":"流程控制","permalink":"https://dxx.fun/tags/流程控制/"}]},{"title":"PHP - 基础 - 运算符","slug":"PHP-基础-运算符","date":"2018-11-14T06:25:00.000Z","updated":"2018-11-14T07:13:36.035Z","comments":true,"path":"20181114/PHP-基础-运算符/","link":"","permalink":"https://dxx.fun/20181114/PHP-基础-运算符/","excerpt":"","text":"错误控制符@PHP的运算符的错误控制符@ PHP支持一个错误运算符：@。当将其放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都将被忽略掉 PHP所有运算符运算符的优先级 括号的使用可以增加代码可读性， 推荐使用 递增/递减 &gt; ！ &gt; 算术运算符 &gt; 大小比较 &gt; (不)相等比较 &gt; 引用 &gt;位运算符(^) &gt; 位运算符(I) &gt; 逻辑与 &gt; 逻辑或 &gt; 三目 &gt; 赋值 &gt;and &gt; xor &gt; or 详细文档 PHP: 运算符优先级 比较运算符 ==和===的区别 ==: 比较值是否相等 ===: 比较值和类型是否相等 等值判断（FALSE的七种情况） 示例: 12345678&lt;?phpif (\"==false\" &amp;&amp; false) &#123;// 非空串为 true echo '1';&#125; elseif ('0' == 0) &#123; // '0' 空字符串0等于 false and 0 等于 false echo '2';&#125; elseif (0.0 == 0) &#123; // '0.0' 字符串0.0等于 false and 0 等于 false echo '3';&#125; 递增/递减运算符 递增/递减运算符不影响布尔值 递减 NULL 值没有效果 递增NULL(NULL++) 值为1 递增和递减在前就先运算符后返回，反之就先返回，后运算（++i, i++） 逻辑运算符 短路作用 || 和 &amp;&amp; 与 or 和 and 的优先级不同 重点: 递增/递减运算符的运算规则 逻辑运算符的短路效果 逻辑运算符多考虑优先级问题 问题12345678910111213141516171819202122232425&lt;?php/** * 下列程序中请写出打印输出的结果 * &lt;?php * $a = 0; * $b = 0; * if ($a = 3 &gt; 0 || $b = 3 &gt; 0) * &#123; * $a++; * $b++; * echo $a. \"\\n\"; * echo $b. \"\\n\"; * &#125; */$a = 0;$b = 0;if ($a = 3 &gt; 0 || $b = 3 &gt; 0) &#123; // $a = true; $b=0; $a++; // true 递增，还是 true $b++; // 0 递增，等于1 echo $a. \"\\n\"; echo $b. \"\\n\";&#125; 12345678910// 1: 3 &gt; 0 == true$a = true || $b = 3 &gt; 0// 2: 3 &gt; 0 == true$a = true || $b = true// 3: $a = true == true$a = true || $b = true// 4: true || $b == true$a = true// 5: $a = true == truetrue","categories":[{"name":"PHP","slug":"PHP","permalink":"https://dxx.fun/categories/PHP/"},{"name":"基础","slug":"PHP/基础","permalink":"https://dxx.fun/categories/PHP/基础/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://dxx.fun/tags/PHP/"},{"name":"基础","slug":"基础","permalink":"https://dxx.fun/tags/基础/"},{"name":"运算符","slug":"运算符","permalink":"https://dxx.fun/tags/运算符/"},{"name":"优先级","slug":"优先级","permalink":"https://dxx.fun/tags/优先级/"}]},{"title":"PHP - 基础 - 常量及数据类型","slug":"PHP-基础-常量及数据类型","date":"2018-11-14T04:59:00.000Z","updated":"2018-11-14T06:09:07.570Z","comments":true,"path":"20181114/PHP-基础-常量及数据类型/","link":"","permalink":"https://dxx.fun/20181114/PHP-基础-常量及数据类型/","excerpt":"","text":"字符串PHP的字符串定义方式及各自区别定义方式 变量和变量, 变量和字符串, 字符串和字符串之间可以用.链接 单引号 不能解析变量 不能解析转义字符, 只能解析单引号和反斜线本身 效率更高 双引号 效率偏低 Heredoc 类似与双引号 Newdoc 类似于单引号 区别 单引号 1234567&lt;?php$a = 'hello world';// 单引号$str = 'a:$a';echo $str; // 输出: a:$a?&gt; 双引号 123&lt;?phpecho \"\\n\"; // 这里需要使用双引号, 单引号不解析转义?&gt; 双引号 1234&lt;?php$str = \"a:$a\";echo $str; // 输出 a:hello world?&gt; Heredoc 12345678910111213&lt;?php$str = &lt;&lt;&lt;EoT a-top $a a-bottomEoT;echo $str;/** 输出 a-top hello world a-bottom*/?&gt; Newdoc 12345678910111213&lt;?php$str = &lt;&lt;&lt;'EoT' a-top $a a-bottomEoT;echo $str; /** 输出 a-top $a a-bottom */?&gt; 数据类型 三大数据类型(标量, 复合, 特殊) 标量浮点类型 浮点类型不能运用到比较运算中(不能用于相等的判断) 12345678910&lt;?php $a = 0.1; $b = 0.7; if($a + $b == 0.8)&#123; &#125;else&#123; // false:$a+$b = 0.7999999999999999 不等于 0.8 &#125;?&gt; 布尔类型FALSE的七种情况 整型0、浮点0.0、空字符串、0字符串、布尔false、空数组、NULL 序号 类型 备注 1 0 整型0 2 0.0 浮点0.0 3 &#39;&#39; 空字符串 4 &#39;0&#39; 0字符串 5 false 布尔false 6 array() 空数组 7 NULL NULL 数组类型超全局数组 $GLOBALS // 包含 2-8 $_REQUEST //包含3-4, 尽量不使用,安全性偏低 $_GET $_POST $_SESSION $_COOKIE $_SERVER $_FIILES $_ENV $_SERVER 常用属性 $_SERVER[&#39;SERVER_ADDR&#39;] 服务器IP地址 $_SERVER[&#39;REMOTE_ADDR&#39;] 客户端IP地址 $_SERVER[&#39;SERVER_NAME&#39;] 服务器名称 $_SERVER[&#39;REQUEST_TIME&#39;] 请求时间 $_SERVER[&#39;HTTP_REFERER&#39;] 上级请求页面 $_SERVER[&#39;HTTP_USER_AGENT&#39;] 浏览器信息 $_SERVER[&#39;QUERY_STRING&#39;] 查询语句, ?后面的值 $_SERVER[&quot;REQUEST_URI&quot;] 域名后面的值，包括/ $_SERVER[&quot;SCRIPT_NAME&quot;] 获取当前脚本的名称 $_SERVER[&#39;HTTP_USER_AGENT&#39;] 浏览器信息 $_SERVER[&#39;PATH_INFO&#39;] NULL NULL的三种情况直接赋值未NULL, 未定义的变量, unset销毁的变量 常量 常量一经定义, 不能被修改, 不能被删除 定义方式 const 更快, 语言结构 define 函数 不能用于类类常量的定义, const可以 预定义常量 __FILE__ 文件路径名 __LINE__ 所在行号 __DIR__ 文件目录 __FUNCTION__ 函数名称 __CLASS__ 类名 __TRAIT__ 5.4特性 TRAIT名称 __METHOD__ 类名+方法名 __NAMESPACE__ NAMESPACE 问题 用PHP写出显示客户端IP与服务器IP的代码。 12345&lt;?phpecho '客户端IP;' . $_SERVER['REMOTE_ADDR'];echo '服务器IP;' . $_SERVER['SERVER_ADDR'];?&gt; __FILE__ 表示什么意思。 所在文件的文件路径+文件名称","categories":[{"name":"PHP","slug":"PHP","permalink":"https://dxx.fun/categories/PHP/"},{"name":"基础","slug":"PHP/基础","permalink":"https://dxx.fun/categories/PHP/基础/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://dxx.fun/tags/PHP/"},{"name":"基础","slug":"基础","permalink":"https://dxx.fun/tags/基础/"},{"name":"常量","slug":"常量","permalink":"https://dxx.fun/tags/常量/"},{"name":"数据类型","slug":"数据类型","permalink":"https://dxx.fun/tags/数据类型/"}]},{"title":"PHP - 基础 - 引用变量","slug":"PHP-基础-引用变量","date":"2018-11-14T03:28:00.000Z","updated":"2018-11-14T04:57:56.911Z","comments":true,"path":"20181114/PHP-基础-引用变量/","link":"","permalink":"https://dxx.fun/20181114/PHP-基础-引用变量/","excerpt":"","text":"PHP的引用变量的概念及定义方式概念在PHP中引用意味着用不同的名字访问同一个变量内容. 定义方式 使用 &amp; 符号 PHP引用变量的原理工作原理 定义变量 Code 12345678910111213&lt;?php // 1.定义一个变量 (内存地址1) $a = range(0, 1000); // 2.定义变量b, 将a变量的值赋值给b (内存地址1) // COW: Copy On Write $b = $a; // ------------------- // $a, $b 指向同一内存空间 // -------------------?&gt; 图示 修改变量 Code 123456789 &lt;?php // 3.修改变量, (内存地址2) $a = range(0, 1000); // ------------------- // $a -&gt; (内存地址2) // $b -&gt; (内存地址1) // -------------------?&gt; 图示 引用变量 Code 1234567891011&lt;?php // 1.定义一个变量 (内存地址1) $a = range(0, 1000); // 2.引用变量, $b指向$a的内存地址 $b = &amp;$a; // ------------------- // $a -&gt; (内存地址2) // $b -&gt; (内存地址2) // -------------------?&gt; 图示 引用变量 Code 123456789 &lt;?php // 4.修改变量, (内存地址2的内容被修改) $a = range(0, 1000); // ------------------- // $a -&gt; (内存地址2) // $b -&gt; (内存地址2) // -------------------?&gt; 图示 unset unset 只会取消引用, 不会销毁空间 unset Code 12345678910111213 &lt;?php // 定义变量, ($a内存地址1) $a = 1; // 引用变量, ($b内存地址1) $b = &amp;$a; // 取消引用 unset($b); // ------------------- // $a -&gt; (内存地址1) // $b -&gt; NULL // -------------------?&gt; 图示 对象 修改对象属性时, 只会对修改的属性进行赋值, 不会将整个对象复制. 问题 写出如下程序的输出结果 123456&lt;?php $data = ['a', 'b', 'c']; foreach($data as $key =&gt; $val) &#123; $val = &amp;$data[$key]; &#125; 程序运行时, 每一次循环结束后变量$data的值是什么? 程序执行完成后, 变量$data的值是什么? 123456789101112131415161718192021// 程序共3次循环// 第一次: $key = 0; $val = 'a'; $val = &amp;$data[0] = 'a';// 此时 $data = ['a', 'b', 'c']// 第二次: $key = 1; $val = 'b'; // $data[0] 与 $val 指向同一内存, 所以 $data[0] = 'b'; $val = &amp;$data[1] = 'b';// 此时 $data = ['b', 'b', 'c']// 第三次: $key = 2; $val = 'c'; // $data[1] 与 $val 指向同一内存, 所以 $data[1] = 'c'; $val = &amp;$data[2] = 'c';// 此时 $data = ['b', 'c', 'c']// 执行完成后: $data = ['b', 'c', 'c'] 使用 memory_get_usage()获取当前使用的内存量 COW(Copy on Write)写入时复制: 一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://dxx.fun/categories/PHP/"},{"name":"基础","slug":"PHP/基础","permalink":"https://dxx.fun/categories/PHP/基础/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://dxx.fun/tags/PHP/"},{"name":"基础","slug":"基础","permalink":"https://dxx.fun/tags/基础/"},{"name":"引用变量","slug":"引用变量","permalink":"https://dxx.fun/tags/引用变量/"}]},{"title":"CSS选择器 匹配H标签","slug":"CSS选择器-匹配H标签","date":"2018-11-02T11:30:00.000Z","updated":"2018-11-02T11:31:25.983Z","comments":true,"path":"20181102/CSS选择器-匹配H标签/","link":"","permalink":"https://dxx.fun/20181102/CSS选择器-匹配H标签/","excerpt":"","text":"1$(&apos;.article :header&apos;) 匹配h1,h2之类的标题","categories":[{"name":"前端","slug":"前端","permalink":"https://dxx.fun/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"https://dxx.fun/tags/css/"}]},{"title":"ubuntu 16.04 配置Rime输入法（中州韵）","slug":"ubuntu-16-04-配置Rime输入法（中州韵）","date":"2018-11-02T11:30:00.000Z","updated":"2018-11-02T11:37:47.290Z","comments":true,"path":"20181102/ubuntu-16-04-配置Rime输入法（中州韵）/","link":"","permalink":"https://dxx.fun/20181102/ubuntu-16-04-配置Rime输入法（中州韵）/","excerpt":"","text":"安装 1sudo apt install fcitx-rime 添加输入法 我是直接在系统设置里添加 安装小鹤双拼 1sudo apt-get install librime-data-double-pinyin 修改输入法配置 1~/.config/rime/default.custom.yaml customization: distribution_code_name: Weasel distribution_version: 0.9.30 generator: &quot;Rime::SwitcherSettings&quot; modified_time: &quot;Mon Jul 21 11:07:43 2014&quot; rime_version: 1.1.2 patch: &quot;ascii_composer/good_old_caps_lock&quot;: true &quot;ascii_composer/switch_key&quot;: Caps_Lock: commit_code Control_L: commit_code Control_R: noop Shift_L: noop Shift_R: commit_code &quot;menu/page_size&quot;: 5 schema_list: - {schema: luna_pinyin} # 朙月拼音 #- {schema: cangjie5} # 倉頡五代 - {schema: luna_pinyin_fluency} #- {schema: luna_pinyin_simp} # 朙月拼音 简化字模式 #- {schema: luna_pinyin_tw} # 朙月拼音 臺灣正體模式 - {schema: double_pinyin_flypy} # 小鶴雙拼 &quot;switcher/hotkeys&quot;: - &quot;Control+grave&quot;","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://dxx.fun/categories/Ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://dxx.fun/tags/ubuntu/"},{"name":"Rime","slug":"Rime","permalink":"https://dxx.fun/tags/Rime/"},{"name":"输入法","slug":"输入法","permalink":"https://dxx.fun/tags/输入法/"}]},{"title":"Django2.0 配置静态文件路由，验证网站所有权","slug":"Django2-0-配置静态文件路由，验证网站所有权","date":"2018-11-02T11:29:00.000Z","updated":"2018-11-02T11:44:54.228Z","comments":true,"path":"20181102/Django2-0-配置静态文件路由，验证网站所有权/","link":"","permalink":"https://dxx.fun/20181102/Django2-0-配置静态文件路由，验证网站所有权/","excerpt":"","text":"Django2.0 配置静态文件路由这个有什么用？在 Google Analytics（分析）、百度统计 添加网站时需要验证网站所有权，这时一般有几种验证方式 如 Google： HTML 文件 - 上传将 HTML 文件上传到您的网站。 HTML 标记 - 向您网站的首页添加元标记。 域名提供商 - 登录到您的域名提供商网站。 Google 跟踪代码管理器 本文就是配置为了 1. HTML 文件， 为什么要用 HTML 文件 来验证？ HTML 标记 需要在网站首页添加&lt;meta&gt; 标签，强迫症，不想加 域名提供商 因为把裸域设成了CNAME，所有用不了这个（好像不应该设置裸域） Google 跟踪代码管理器 不知道为什么添加不了，以后再看 HTML文件 就剩你了 设置方法 导入静态视图 django.contrib.staticfiles.views.serve视图会在静态文件目录查找指定的path文件 也就是要把HTML文件存放在STATIC目录,或者指定document_root 设置urls.py1fromc 添加路由 使用django.urls.path 1234 path('googledadae4a424161111.html', serve, kwargs=&#123;'path':'googledadae4a424161111.html'&#125;, name='googleAnalytics'), 使用django.conf.urls.url django2.0 添加了re_path，url是re_path的别名，完全调用re_path 1234urlpatterns = [# .... 其他配置url(r'^googledadae4a424161111.html$', serve, name='googleAnalytics'),] 懒人专用配置 匹配所有html文件 1234urlpatterns = [# .... 其他配置url(r'^(?P&lt;path&gt;[a-zA-Z0-9]*\\.html)$', serve, name='html_file'),]","categories":[{"name":"Django","slug":"Django","permalink":"https://dxx.fun/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dxx.fun/tags/Python/"},{"name":"静态文件","slug":"静态文件","permalink":"https://dxx.fun/tags/静态文件/"},{"name":"DJango","slug":"DJango","permalink":"https://dxx.fun/tags/DJango/"}]},{"title":"ubuntu 16.04 python 3.x 安装OpenSSL","slug":"ubuntu-16-04-python-3-x-安装OpenSSL","date":"2018-11-02T11:29:00.000Z","updated":"2018-11-02T11:38:15.828Z","comments":true,"path":"20181102/ubuntu-16-04-python-3-x-安装OpenSSL/","link":"","permalink":"https://dxx.fun/20181102/ubuntu-16-04-python-3-x-安装OpenSSL/","excerpt":"","text":"错误提示：1Can&apos;t connect to HTTPS URL because the SSL module is not available. 连接HTTPS时，提示SSL不可用 测试12# 进入python$ python3 # or python3.6 12# 导入SSL模块&gt;&gt;&gt; import ssl 如果出现下面提示，则Python不支持SSL。 解决方案下载文件 OpenSSL $ wget http://www.openssl.org/source/openssl-1.0.2e.tar.gz Python3.6 - 选择需要的版本 $wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz 安装OpenSSL1234# 解压文件tar xvzf openssl-1.0.2e.tar.gz# 进入目录$ ./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl 123$ make$ make test$ sudo make install Python进入目录123#解压$ tar xvzf Python-3.6.2.tgz$ cd Python-3.6.2 修改安装配置 使用VIM打开文件Modules/Setup.dist文件，搜索SSL，取消四行注释 1$ vim Modules/Setup.dist 开始安装 完成上面操作就可以安装了，执行下面3行代码 123$ ./configure$ make$ sudo make install 完成！ 不出意外已经安装完成，下面检测一下。 进入python 1$ python3 导入SSL模块 1&gt;&gt;&gt; import ssl 没有报错就已经成功了！","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://dxx.fun/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://dxx.fun/tags/Ubuntu/"},{"name":"python3","slug":"python3","permalink":"https://dxx.fun/tags/python3/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://dxx.fun/tags/OpenSSL/"}]},{"title":"Python 基础 - 数据类型 - 字符串类型与操作","slug":"Python-基础-数据类型-字符串类型与操作","date":"2018-11-02T11:28:00.000Z","updated":"2018-11-02T11:39:54.874Z","comments":true,"path":"20181102/Python-基础-数据类型-字符串类型与操作/","link":"","permalink":"https://dxx.fun/20181102/Python-基础-数据类型-字符串类型与操作/","excerpt":"","text":"#数据类型 字符串 str格式 单引号 双引号 三引号 多行. 利用其特点,可用于注释 1. 切片(同列表) 使用[M:N:K]根据步长对字符串切片M 缺失表示至开头N 缺失表示至结尾K 缺失表示步长1 正向递增序号 ‘hello world’[:5] == ‘hello’ 反向递减序号 ‘hello world’[-5:] == ‘world’ 步长 ‘1234567890’[::2] == ‘13579’ 步长为负, 反转字符串 ‘1234567890’[::-1] == ‘0987654321’ 2. 转义符 (在行尾时) 续行符 \\\\ 反斜杠符号 \\’ 单引号 \\” 双引号 \\b 退格(Backspace,光标向前退一格) \\000 空 \\n 换行(光标移动到下行首) \\r 回车(光标移动到本行首) \\t 横向制表符 \\a 响铃 \\e 转义 \\v 纵向制表符 \\f 换页 \\oyy 八进制数，yy代表的字符，例如：\\o12代表换行 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 3. 字符串操作符x + y- 连接两个字符串x和y n*x 或 x*n- 复制n次字符串x x in s- 如果x是s的子串, 返回True, 否则返回False 4. 字符串处理函数len(x)- 长度, 返回字符串x的长度 - len(&quot;一二三456&quot;) 结果为6 str(x)- 任意类型x所对应的字符串形式 - str(1.23) 结果为&quot;1.23&quot; - str([1, 2]) 结果为&quot;[1, 2]&quot; hex(x)- 整数x的十六进制小写形式字符串 - hex(425) 结果为&quot;0x1a9&quot; oct(x)- 整数x的八进制小写形式字符串 - oct(425) 结果为&quot;0o651&quot; chr(u)- u为Unicode编码, 返回其对应的字符 ord(x)- x为字符, 返回其对应的Unicode编码 str.lower()- 返回字符串的副本, 全部字符小写 - &apos;AbcDeF&apos;.upper() 结果为&quot;abcdef&quot; str.upper()- 返回字符串的副本, 全部字符大写 - &apos;AbcDeF&apos;.upper() 结果为&quot;ABCDEF&quot; str.split(sep=None)- 返回一个列表, 由str根据sep被分割的部分组成 - &quot;A,B,C&quot;.split(&quot;,&quot;) 结果为[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] str.count(sub)- 返回子串sub在str中出现的次数 - &quot;a apple a day&quot;.count(&quot;a&quot;) 结果为4 str.replace(old, new)- 返回字符串str副本, 所有old子串被替换为new - &quot;python&quot;.replace(&quot;n&quot;, &quot;n123&quot;) 结果为&quot;python123&quot; str.center(width, fillchar=” “)- 字数串str根据宽度width居中, fillchar可选 - &quot;python&quot;.center(10,&apos;=&apos;) 结果为&apos;==python==&apos; str.strip(chars)- 从str中去掉在其左侧和右侧,chars中列出的字符 - &quot;== python ==&quot;.strip(&quot; =pn&quot;) 结果为&quot;ytho&quot; str.join(iter)- 主要用于字符串分割 - 在iter变量除最后元素外每个元素后增加一个str - &quot;,&quot;.join(&quot;12345&quot;) 结果为 &quot;1,2,3,4,5&quot; ### 5. 字符串格式化 “{0} / {1} / {2}”.format(2018, 10, 24) >> 2018 / 10 / 24 {序号} 为槽 槽的内部对格式化的配置方式{&lt;参数序号&gt;:&lt;格式控制标记&gt;}:&lt;填充&gt;|&lt;对齐&gt;|&lt;宽度&gt;|&lt;,&gt;|&lt;.精度&gt;|&lt;类型&gt; 填充 用于填充的单个字符 对齐 &lt; 左对齐 > 右对齐 ^ 居中对齐 宽度 槽设定的输出宽度 ,(逗号) 数字的千位分隔符 .精度 浮点数小数精度 或 字数串最大输出长度 类型 整数类型 b c d o x X 浮点数类型 e E f % 示例123\"&#123;0:=^50,.3f&#125;\".format(500000.12345)'===================500,000.123====================' 0 序号 = 填充 ^ 居中对齐 50 宽度50 , 千位分割 .3 保留3为小数 f 浮点类型 EndAD https://zfdev.com https://dxx.fun","categories":[{"name":"Python","slug":"Python","permalink":"https://dxx.fun/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dxx.fun/tags/Python/"},{"name":"字符串","slug":"字符串","permalink":"https://dxx.fun/tags/字符串/"},{"name":"String","slug":"String","permalink":"https://dxx.fun/tags/String/"}]},{"title":"ubuntu安装node vue","slug":"ubuntu安装node-vue","date":"2018-11-02T11:28:00.000Z","updated":"2018-11-02T11:38:32.773Z","comments":true,"path":"20181102/ubuntu安装node-vue/","link":"","permalink":"https://dxx.fun/20181102/ubuntu安装node-vue/","excerpt":"","text":"Nodejs 下载 1https://nodejs.org/dist/v8.11.1/node-v8.11.1-linux-x64.tar.xz 解压 1# 安装(移动) 12$sudo mkdir /usr/local/node/$sudo mv node-v8.11.1-linux-x64 /usr/local/node/v8.11.1 软链接 12$sudo ln -s /usr/local/node/v8.11.1/bin/node /usr/local/bin/node$sudo ln -s /usr/local/node/v8.11.1/bin/npm /usr/local/bin/npm 安装cnpm 12$sudo npm install -g cnpm --registry=https://registry.npm.taobao.org$sudo ln -s /usr/local/node/v8.11.1/bin/cnpm /usr/local/bin/cnpm 添加环境变量 1vim ~/.bashrc .bashrc 123export NODE_HOME=/usr/local/node/v8.11.1/export PATH=$PATH:$NODE_HOME/bin export NODE_PATH=$NODE_HOME/lib/node_modules 执行 1source ~/.bashrc VUE 安装1sudo cnpm install --global vue-cli","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://dxx.fun/categories/Ubuntu/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://dxx.fun/tags/Node/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://dxx.fun/tags/Ubuntu/"},{"name":"Vue","slug":"Vue","permalink":"https://dxx.fun/tags/Vue/"}]},{"title":"Django 2.0 静态文件404解决方法","slug":"Django-2-0-静态文件404解决方法","date":"2018-11-02T11:27:00.000Z","updated":"2018-11-02T11:45:57.244Z","comments":true,"path":"20181102/Django-2-0-静态文件404解决方法/","link":"","permalink":"https://dxx.fun/20181102/Django-2-0-静态文件404解决方法/","excerpt":"","text":"Django 在 Debug=True 时, 不需要配置. Django会在App中需找STATIC路径.因为服务器一直用Nginx配置STATIC路径, 所以一直没有配置开发环境的STATIC路径,但需要测试生产环境还是不方便, 所以设置一下Django中的STATIC路由. 配置project/urls.pyfrom django.views.static import serve urlpatterns = [ url(r&apos;^static/(?P&lt;path&gt;.*)$&apos;, serve, {&apos;document_root&apos;: settings.STATIC_ROOT}, name=&apos;static&apos;), ... ] project/settings.pyINSTALLED_APPS = [ &apos;django.contrib.staticfiles&apos;, ...... ] STATIC_URL = &apos;/static/&apos; STATIC_ROOT = os.path.join(BASE_DIR, &apos;static&apos;) STATICFILES_DIRS = ( os.path.join(BASE_DIR, &apos;apps/appname/static/&apos;), ) 路径STATIC project/static/… http://127.0.0.1:8000/static/... APP_STATIC project/.?/appname/STATIC http://127.0.0.1:8000/static/... 部署时使用需收集App下的STATIC文件到project/static/, 命令 python manage.py collectstatic EndAD https://dxx.fun/c/Python.htmlhttps://zfdev.com","categories":[{"name":"Django","slug":"Django","permalink":"https://dxx.fun/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dxx.fun/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://dxx.fun/tags/Django/"},{"name":"静态文件","slug":"静态文件","permalink":"https://dxx.fun/tags/静态文件/"}]},{"title":"python虚拟环境 Virtualenv及Virtualenvwrapper","slug":"python虚拟环境-Virtualenv及Virtualenvwrapper","date":"2018-11-02T11:27:00.000Z","updated":"2018-11-02T11:39:26.676Z","comments":true,"path":"20181102/python虚拟环境-Virtualenv及Virtualenvwrapper/","link":"","permalink":"https://dxx.fun/20181102/python虚拟环境-Virtualenv及Virtualenvwrapper/","excerpt":"","text":"虚拟环境虚拟环境原理介绍： 虚拟环境相当于一个抽屉，在这个抽屉中安装的任何软件包都不会影响到其他抽屉。并且在项目中，我可以指定这个项目的虚拟环境来配合我的项目。比如我们现在有一个项目是基于Django 1.10.x版本，又有一个项目是基于Django 0.9.x的版本，那么这时候就可以创建两个虚拟环境，在这两个虚拟环境中分别安装Django 1.10.x和Django 0.9.x来适配我们的项目。 virtualenv安装virtualenv：virtualenv是用来创建虚拟环境的软件工具，我们可以通过pip或者pip3来安装： pip install virtualenv pip3 install virtualenv 创建虚拟环境：创建虚拟环境非常简单，通过以下命令就可以创建了： virtualenv [虚拟环境的名字] 如果你当前的Python3/Scripts的查找路径在Python2/Scripts的前面，那么将会使用python3作为这个虚拟环境的解释器。如果python2/Scripts在python3/Scripts前面，那么将会使用Python2来作为这个虚拟环境的解释器。 进入环境：虚拟环境创建好了以后，那么可以进入到这个虚拟环境中，然后安装一些第三方包，进入虚拟环境在不同的操作系统中有不同的方式，一般分为两种，第一种是Windows，第二种是*nix： windows进入虚拟环境：进入到虚拟环境的Scripts文件夹中，然后执行activate。 *nix进入虚拟环境：source /path/to/virtualenv/bin/activate 一旦你进入到了这个虚拟环境中，你安装包，卸载包都是在这个虚拟环境中，不会影响到外面的环境。 退出虚拟环境：退出虚拟环境很简单，通过一个命令就可以完成： deactivate 创建虚拟环境的时候指定Python解释器：在电脑的环境变量中，一般是不会去更改一些环境变量的顺序的。也就是说比如你的Python2/Scripts在Python3/Scripts的前面，那么你不会经常去更改他们的位置。但是这时候我确实是想在创建虚拟环境的时候用Python3这个版本，这时候可以通过-p参数来指定具体的Python解释器： virtualenv -p C:\\Python36\\python.exe [virutalenv name] virtualenvwrapper： virtualenvwrapper这个软件包可以让我们管理虚拟环境变得更加简单。不用再跑到某个目录下通过virtualenv来创建虚拟环境，并且激活的时候也要跑到具体的目录下去激活。 安装virtualenvwrapper：*nix：pip install virtualenvwrapper windowspip install virtualenvwrapper-win virtualenvwrapper基本使用：创建虚拟环境：mkvirtualenv my_env 那么会在你当前用户下创建一个Env的文件夹，然后将这个虚拟环境安装到这个目录下。如果你电脑中安装了python2和python3，并且两个版本中都安装了virtualenvwrapper，那么将会使用环境变量中第一个出现的Python版本来作为这个虚拟环境的Python解释器。 切换到某个虚拟环境：workon my_env 退出当前虚拟环境：deactivate 删除某个虚拟环境：rmvirtualenv my_env 列出所有虚拟环境：lsvirtualenv 进入到虚拟环境所在的目录：cd virtualenv 修改mkvirtualenv的默认路径：在我的电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量中添加一个参数WORKON_HOME，将这个参数的值设置为你需要的路径。 创建虚拟环境的时候指定Python版本：在使用mkvirtualenv的时候，可以指定–python的参数来指定具体的python路径： mkvirtualenv --python==C:\\Python36\\python.exe hy_env virtualenvwrapper 命令的完全列表 参考：http://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html EndAD","categories":[{"name":"Python","slug":"Python","permalink":"https://dxx.fun/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://dxx.fun/tags/Python/"},{"name":"Virtualenv","slug":"Virtualenv","permalink":"https://dxx.fun/tags/Virtualenv/"},{"name":"Virtualenvwrapper","slug":"Virtualenvwrapper","permalink":"https://dxx.fun/tags/Virtualenvwrapper/"}]},{"title":"pm2","slug":"pm2","date":"2018-11-02T11:16:00.000Z","updated":"2018-11-02T11:34:28.122Z","comments":true,"path":"20181102/pm2/","link":"","permalink":"https://dxx.fun/20181102/pm2/","excerpt":"","text":"run.js12345678910//runconst &#123; exec &#125; = require(&apos;child_process&apos;)exec(&apos;hexo server -i 0.0.0.0 -p 8020 -d&apos;,(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log(&apos;exec error: $&#123;error&#125;&apos;) return &#125; console.log(&apos;stdout: $&#123;stdout&#125;&apos;); console.log(&apos;stderr: $&#123;stderr&#125;&apos;);&#125;) source","categories":[{"name":"前端","slug":"前端","permalink":"https://dxx.fun/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://dxx.fun/tags/Hexo/"},{"name":"Node","slug":"Node","permalink":"https://dxx.fun/tags/Node/"},{"name":"pm2","slug":"pm2","permalink":"https://dxx.fun/tags/pm2/"}]},{"title":"hexo-admin deploy","slug":"hexo-admin-deploy","date":"2018-11-02T11:09:00.000Z","updated":"2018-11-02T11:34:49.955Z","comments":true,"path":"20181102/hexo-admin-deploy/","link":"","permalink":"https://dxx.fun/20181102/hexo-admin-deploy/","excerpt":"","text":"1. _config.yml12admin: deployCommand: &apos;sh hexo-deploy.sh&apos; 2. hexo-deploy.sh1hexo g -d 3. blog\\node_modules\\hexo-admin\\deploy.js old 1var proc = spawn(command, [message], &#123;detached: true&#125;); new 1var proc = spawn((process.platform === &quot;win32&quot; ? &quot;hexo.cmd&quot; : &quot;hexo&quot;), [&apos;d&apos;, &apos;-g&apos;]);","categories":[{"name":"前端","slug":"前端","permalink":"https://dxx.fun/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://dxx.fun/tags/Hexo/"},{"name":"deploy","slug":"deploy","permalink":"https://dxx.fun/tags/deploy/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-11-02T08:27:02.487Z","updated":"2018-11-02T08:27:02.487Z","comments":true,"path":"20181102/hello-world/","link":"","permalink":"https://dxx.fun/20181102/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}