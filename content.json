{"meta":{"title":"Blog","subtitle":"博客","description":"个人博客","author":"Greendev","url":"https://zfdev.com"},"pages":[{"title":"About","date":"2018-11-02T08:27:02.487Z","updated":"2018-11-02T08:27:02.487Z","comments":true,"path":"about/index.html","permalink":"https://zfdev.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2018-11-02T08:27:02.487Z","updated":"2018-11-02T08:27:02.487Z","comments":true,"path":"categories/index.html","permalink":"https://zfdev.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-11-02T08:27:02.487Z","updated":"2018-11-02T08:27:02.487Z","comments":true,"path":"tags/index.html","permalink":"https://zfdev.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Easy HTTP–not Just a Catchy Name","slug":"Easy-HTTP–not-Just-a-Catchy-Name","date":"2019-01-06T08:56:00.000Z","updated":"2019-01-06T10:31:43.299Z","comments":true,"path":"20190106/Easy-HTTP–not-Just-a-Catchy-Name/","link":"","permalink":"https://zfdev.com/20190106/Easy-HTTP–not-Just-a-Catchy-Name/","excerpt":"","text":"I was recently referred to EasyHTTP by it’s creator, Hadi Hariri. Hadi was looking at some code I had sent him regarding my work with the TeamCity REST API and thought that things could be a little easier and less verbose. 我最近被它的创造者Hadi Hariri称为EasyHTTP。 Hadi正在查看我发给他的关于我使用TeamCity REST API的一些代码，并认为事情可能会更简单，更简洁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Caller &#123; public Uri CreateUri(string relativeUrl) &#123; //url build here &#125; public HttpWebRequest CreateWebRequest(Uri uri) &#123; HttpWebRequest webRequest = (HttpWebRequest)WebRequest.Create(uri); webRequest.Credentials = new NetworkCredential(_configuration.UserName, _configuration.Password); webRequest.Proxy = null; return (webRequest); &#125; public string Request(Uri uri) &#123; HttpWebRequest webRequest = CreateWebRequest(uri); webRequest.Accept = \"application/json\"; string output = string.Empty; try &#123; using (var response = webRequest.GetResponse()) &#123; using (var stream = new StreamReader(response.GetResponseStream(), Encoding.GetEncoding(1252))) &#123; output = stream.ReadToEnd(); &#125; &#125; &#125; catch (WebException ex) &#123; if (ex.Status == WebExceptionStatus.ProtocolError) &#123; using (var stream = new StreamReader(ex.Response.GetResponseStream())) &#123; output = stream.ReadToEnd(); &#125; &#125; else if (ex.Status == WebExceptionStatus.Timeout) &#123; output = \"Request timeout is expired.\"; &#125; &#125; return output; &#125; &#125; In summary my application creates a new HttpWebRequest passing in the request type as a magic string. It opens a stream to read the JSON response and that JSON is then de-serialised to an entity. It was very messy. In order to call this class from my application I would have had to do the follow: 总之，我的应用程序创建了一个新的HttpWebRequest，将请求类型作为魔术字符串(magic string)传递。 它打开一个流来读取JSON响应，然后将JSON反序列化为实体。 这非常凌乱。 为了从我的应用程序中调用此类，我将不得不执行以下操作： 12345678public IEnumerable&lt;Project&gt; GetAllProjects()&#123; var uri = _caller.CreateUri(\"/URL\"); var request = _caller.Request(uri); var projects = JsonConvert.DeserializeObject&lt;ProjectWrapper&gt;(request).Projects; return projects;&#125; There is absolutely no mention of whether the request was a GET never mind a PUT or a DELETE. This is where EasyHTTP came in for me. 绝对没有提到请求是否是GET，PUT还是DELETE。 这就是EasyHTTP为我提供的地方。 1234567891011121314151617181920212223242526272829303132public class Caller&#123; public T Get&lt;T&gt;(string urlPart) &#123; var request = CreateHttpRequest(_configuration.UserName, _configuration.Password); string url = CreateUrl(urlPart); try &#123; var staticBody = request.Get(url).StaticBody&lt;T&gt;(); return staticBody; &#125; catch (HttpException ex) &#123; //do something here for an outut throw; &#125; &#125; private string CreateUrl(string urlPart) &#123; var protocol = _configuration.UseSSL ? \"https://\" : \"http://\"; return string.Format(\"&#123;0&#125;&#123;1&#125;&#123;2&#125;\", protocol, _configuration.HostName, urlPart); &#125; HttpClient CreateHttpRequest(string userName, string password) &#123; var httpClient = new HttpClient(); httpClient.Request.Accept = HttpContentTypes.ApplicationJson; httpClient.Request.SetBasicAuthentication(userName, password); return httpClient; &#125;&#125; I was able to make a generic method for a GET request. This method takes a url and a type and with the help of JsonFx, de-serialises the response back to the requested type. THis was a great way to take the hassle out of my old code where I was creating a Url, calling a request and then de-serialising it. The code in the calling class now looks as follows: 我能够为GET请求创建一个通用方法。此方法采用url和类型，并在JsonFx的帮助下，将响应内容(response)反序列化回请求的类型。 这是解决我的旧代码的麻烦的一个很好的方式，我在创建一个Url，调用请求然后反序列化它。 调用类中的代码现在看起来如下： 12345public List&lt;Project&gt; GetAllProjects()&#123; var projectWrapper = _caller.Get&lt;ProjectWrapper&gt;(\"/Url\"); return projectWrapper.Project;&#125; I was originally using the Newtonsoft JSON library for my de-serialising my JSON back to types and to do that I had to decorate the properties with code similar to the following: 我最初使用Newtonsoft JSON library将我的JSON反序列化为类型，为此我必须使用它来装饰属性 代码类似于以下内容： 12[JsonProperty(PropertyName = “id”)]public string Id &#123;get; set;&#125; This would effectively map a piece of JSON to a property that was not named exactly the same. EasyHTTP took care of this for me as well. To quote Hadi, EasyHTTP handles mapping as follows: 这样可以有效地将一段JSON映射到一个未命名为 exactly的属性。 EasyHTTP也为我解决了这个问题。 引用Hadi，EasyHTTP处理映射如下： “For mapping properties, it handles camelcase, lowercase and a bunch of other conventions. You can also specify explicitly” “对于映射属性，它处理camelcase，小写和一些其他约定。 你也可以明确指定” Using EasyHTTP, I was able to cut at least 2 lines of code per method in the client code. I was also able to delete an attribute that was present on all properties in the entities in a little bit of work. 使用EasyHTTP，我能够在客户端代码中为每个方法删除至少2行代码。 我还能够在一些工作中删除实体中的所有属性。 The added distinction of creating the notion of GETs, PUTs and DELETE calls from each other mean that my class can be extended much easier. Hadi has written a post on EasyHTTP on his blog. I would strongly suggest reading this and discovering if you can use this application in place of old HttpWebRequest calls. Its cleaner and helps to make code a little bit more DRY. My thanks to Hadi (and any contributors there may be) for making my work in this area a little easier! 创建GET，PUT和DELETE调用概念的额外区别意味着我的类可以更容易地扩展。 Hadi在他的博客上写了一篇关于EasyHTTP的文章。 我强烈建议阅读本文并发现是否可以使用此应用程序代替旧的HttpWebRequest调用。 它更干净，有助于使代码更简练。 我要感谢Hadi（以及可能的任何贡献者）让我在这方面的工作变得更轻松！ Easy HTTP–not just a catchy name by Paul Stack","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"reprint","slug":"C/EasyHTTP/reprint","permalink":"https://zfdev.com/categories/C/EasyHTTP/reprint/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"reprint","slug":"reprint","permalink":"https://zfdev.com/tags/reprint/"}]},{"title":"Easyhttp by Hadi Hariri","slug":"Easyhttp-by-Hadi-Hariri","date":"2019-01-06T08:44:00.000Z","updated":"2019-01-06T10:32:29.324Z","comments":true,"path":"20190106/Easyhttp-by-Hadi-Hariri/","link":"","permalink":"https://zfdev.com/20190106/Easyhttp-by-Hadi-Hariri/","excerpt":"","text":"最近，我编写的大部分代码都以某种方式与HTTP服务器进行通信。 无论是“ReSTful”服务还是“Wanna-be-ReSTful”服务，我都需要进行GET，POST，PUT等操作并与JSON配合。 在几次围绕WebRequest进行简单封装之后，我决定是时候将其正式化。于是就有了EasyHttp。它已经在GitHub上待了很长一段时间，我和其他人一直在将它用于几个项目，所以我认为它已经到了让更多人尝试的时候了，如果他们愿意的话。 描述EasyHttp功能的最佳方法就是代码 123456var http = new HttpClient&#123; Request = &#123; Accept = HttpContentTypes.ApplicationJson &#125;&#125;var response = http.Get(\"http://domain.com/customer/25\");var customer = response.StaticBody&lt;Customer&gt;(); 代码描述：我们创建了一个HttpClient实例，并指示我们接受内容类型application/json（因为在这种情况下，服务器返回给我们的是json）。 通过指定此Accept头，EasyHttp知道如何解码请求（request）。 我们如何得到响应(response)？在上面的代码中，我们使用StaticBody方法，它为我们提供了一个强类型客户(strongly-typed Customer)。 但我们还有其他选择： 12345678var http = new HttpClient&#123; Request = &#123; Accept = HttpContentTypes.ApplicationJson &#125;&#125;;var response = http.Get(\"http://domain.com/customer/25\");dynamic customer = response.DynamicBody();Console.WriteLine(customer.Name);Console.WriteLine(customer.Email); 在这种情况下，我们想要返回一个动态类型，因此我们调用DynamicBody方法。EasyHttp将自动反序列化对动态对象的响应。这允许我们访问属性而不必提前声明类型（在使用JSON时非常有用）。最后，我们还可以通过RawText属性访问原始响应。 如果我们想要数据流(stream)传输到文件，我们只需： 12var http = new HttpClient();http.GetAsFile(\"http://hadihariri.com/header.png\", @\"C:\\Temp\\header.png\"); 使用其他方法(Http verbs)几乎是相同的过程。假设我们想要创建一个调用服务的客户端： 1234567var http = new HttpClient();var customer = new Customer()&#123; Name = \"Joe Smith\", Email = \"Joe@Gmail.com\"&#125;;http.Post(\"http://domain.com/customer\", customer, HttpContentTypes.ApplicationJson); 在这种情况下，我们提交了一个Customer对象，并要求EasyHttp使用application/json对其进行编码。与接收响应时类似，在发出需求正文的请求时，我们也可以使用动态对象。因此，这也可以使用： 12345var http = new HttpClient()dynamic customer = new ExpandoObject()customer.Name = \"Joe Smith\";customer.Email = \"Joe@Gmail.com\";http.Post(\"http://domain.com/customer\", customer, HttpContentTypes.ApplicationJson); 在内部，EasyHttp正在使用优秀的JsonFX，它目前支持JSON和XML 编码和解码。EasyHttp通过添加www-form-urlencoded的编码支持来扩展它。用其他格式扩展它应该很容易。 除了GET和POST，EasyHttp还支持PUT，DELETE和HEAD。请求和响应标头作为属性显示，因此我们不必手动添加标头，而是可以单独分配它们（其中一些标记来自现有的WebRequest）。 总结这就是它的全部内容。 正如我所提到的，我一直在使用它与CouchDB交互，作为YouTrackSharp和其他一些项目的一部分。它远不是全部功能，但是我添加的东西，因为我或部分人需要使用它们。 随意下载并使用它。源代码在GitHub上，Issue Tracker在CodeBetter上。如果您对运行测试感兴趣，则需要CouchDB。我最初写这篇文章是因为我需要为CouchDB做一些事情，它是测试不同Http Verbs的一个很好的平台（是的，它们是集成测试，而不是单元测试）。 by Hadi Hariri","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"reprint","slug":"C/EasyHTTP/reprint","permalink":"https://zfdev.com/categories/C/EasyHTTP/reprint/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"reprint","slug":"reprint","permalink":"https://zfdev.com/tags/reprint/"}]},{"title":"EasyHTTP - Home","slug":"EasyHTTP-Home","date":"2019-01-06T08:15:00.000Z","updated":"2019-01-06T09:19:00.188Z","comments":true,"path":"20190106/EasyHTTP-Home/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Home/","excerpt":"","text":"Welcome to the EasyHttp wiki! Nugetnuget包 可以在nuget库中找到。 文档 HttpClient Request Response Get Post Put Patch Options Head Delete HttpStatusCodes Blogs and articles Easyhttp by Hadi Hariri Easy HTTP–not just a catchy name by Paul Stack servicestack, restservice and easyhttp by Christiaan Baes Nancy and VB.Net: Using easyhttp as our client by Christiaan Baes Support for segments in easyhttp by Christiaan Baes","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Documentation","slug":"Documentation","permalink":"https://zfdev.com/tags/Documentation/"}]},{"title":"EasyHTTP - Delete","slug":"EasyHTTP-Delete","date":"2019-01-06T08:10:00.000Z","updated":"2019-01-06T08:40:55.870Z","comments":true,"path":"20190106/EasyHTTP-Delete/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Delete/","excerpt":"","text":"根据W3，Delete方法执行以下操作。 DELETE方法请求源服务器删除Request-URI标识的资源。 可以通过源服务器上的人为干预（或其他方式）覆盖此方法。 即使从源服务器返回的状态代码表明操作已成功完成，也无法保证客户端已执行该操作。 但是，服务器不应该指示成功，除非在给出响应时，它打算删除资源或将其移动到不可访问的位置。 有几种方法可以使用Easyhttp进行删除(Delete)。 这将向指定的uri发送Delete方法。 123var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;var result = http.Delete(\"http://localhost/trees?Id=1\"); 这与此相同。 123var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;var result = http.Delete(\"http://localhost/trees\", new &#123; .Id = 1&#125;); 或者对于喜欢参数为Segments的服务，您可以执行此操作。 123var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;var result = http.Delete(\"http://localhost/trees/1\"); 这与此相同。 1234var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;http.Request.ParametersAsSegments = true;var result = http.Delete(\"http://localhost/trees\", new &#123; .Id = 1&#125;);","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Delete","slug":"Delete","permalink":"https://zfdev.com/tags/Delete/"}]},{"title":"EasyHTTP - Head","slug":"EasyHTTP-Head","date":"2019-01-06T08:06:00.000Z","updated":"2019-01-06T08:41:06.066Z","comments":true,"path":"20190106/EasyHTTP-Head/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Head/","excerpt":"","text":"根据W3，Head方法执行以下操作。 HEAD方法与GET相同，只是服务器不能在响应中返回消息体。 响应HEAD请求的HTTP头中包含的元信息应该与响应GET请求时发送的信息相同。 该方法可用于获得关于请求所暗示的实体的元信息，而无需转移实体主体本身。 此方法通常用于测试超文本链接的有效性，可访问性和最近的修改。 转到Get方法获取语法。 只需像这样替换Head方法。 123456var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;var result = http.Get(\"http://localhost:55360/trees\", new &#123; Id = 2 &#125;);var tree = result.DynamicBody;Console.WriteLine(tree.Id);Console.WriteLine(tree.Genus);","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Head","slug":"Head","permalink":"https://zfdev.com/tags/Head/"}]},{"title":"EasyHTTP - PutFile","slug":"EasyHTTP-Putfile","date":"2019-01-06T08:01:00.000Z","updated":"2019-01-06T08:41:13.358Z","comments":true,"path":"20190106/EasyHTTP-Putfile/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Putfile/","excerpt":"","text":"要将文件上载到Web服务器上的资源，可以使用HttpClient对象的PutFile方法。 为此，您需要传递文件所在的uri。 本地文件的路径。 以及您要上传的内容类型(contentype)，所有字符串。 123var httpClient = new HttpClient();var imageFile = Path.Combine(\"Helpers\", \"test.jpg\");httpClient.PutFile(string.Format(\"&#123;0&#125;/fileupload/test.jpg\", \"http://localhost:16000\"), imageFile, \"image/jpeg\");","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"PutFile","slug":"PutFile","permalink":"https://zfdev.com/tags/PutFile/"}]},{"title":"EasyHTTP - Put","slug":"EasyHTTP-Put","date":"2019-01-06T07:54:00.000Z","updated":"2019-01-06T08:41:22.298Z","comments":true,"path":"20190106/EasyHTTP-Put/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Put/","excerpt":"","text":"根据 Spec Put用于。 PUT方法请求将所包含的实体存储在提供的Request-URI下。如果Request-URI引用已经存在的资源，则封闭的实体应该被视为驻留在源服务器上的实体的修改版本。如果Request-URI未指向现有资源，并且该URI能够被请求用户代理定义为新资源，则源服务器可以使用该URI创建资源。如果创建了新资源，则源服务器必须通过201（已创建）响应通知用户代理。如果修改了现有资源，则应该发送200（OK）或204（No Content）响应代码以指示请求成功完成。如果无法使用Request-URI创建或修改资源，则应该给出适当的错误响应，以反映问题的性质。实体的接收者绝不能忽略它不理解或实现的任何Content- *（例如Content-Range）头，并且在这种情况下必须返回501（未实现）响应。 您可以使用Put方法并使用静态，匿名或动态对象来放置服务。 让我们以Tree为例。 我们的Tree对象看起来像这样。 12345public class Tree&#123; public int Id &#123; get; set ; &#125; public string Genus &#123; get; set; &#125;&#125; 现在我们可以像这样把对象放到我们的服务上。 12345var tree = new Tree(); tree.Id = 1; tree.Genus = \"Fagus\";var http = new HttpClient();http.Put(\"url\", tree, HttpContentTypes.ApplicationJson); 或者我们可以使用这样的匿名对象来完成它。 12var http = new HttpClient();http.Put(\"url\", new&#123;Id=1, Genus=\"Fagus\"&#125;, HttpContentTypes.ApplicationJson); 或者你可以Put一个动态类型。 12345var tree = new ExpandoObject(); tree.Id = 1; tree.Genus = \"Fagus\";var http = new HttpClient();http.Put(\"url\", tree, HttpContentTypes.ApplicationJson); 您可以选择内容类型。 您还可以使用PutFile方法上传文件。","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Put","slug":"Put","permalink":"https://zfdev.com/tags/Put/"}]},{"title":"EasyHTTP - Post","slug":"EasyHTTP-Post","date":"2019-01-06T07:43:00.000Z","updated":"2019-01-06T16:34:04.873Z","comments":true,"path":"20190106/EasyHTTP-Post/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Post/","excerpt":"","text":"根据W3，post方法执行以下操作 POST方法用于请求源服务器接受请求中包含的实体作为Request-URI中Request-URI标识的资源的新下级。 POST旨在允许统一的方法来涵盖以下功能： 现有资源的注释; 在公告栏，新闻组，邮件列表或类似文章组中发布消息; 向数据处理流程提供数据块，例如提交表单的结果; 通过追加操作扩展数据库。 您可以使用post方法并使用静态，匿名或动态对象提交到服务器。 让我们以Tree为例。 我们的Tree对象看起来像这样。 12345public class Tree&#123; public int Id &#123; get; set ; &#125; public string Genus &#123; get; set; &#125;&#125; 现在我们可以像这样将对象提交到我们的服务器中。 12345var tree = new Tree(); tree.Id = 1; tree.Genus = \"Fagus\";var http = new HttpClient();http.Post(\"url\", tree, HttpContentTypes.ApplicationJson); 或者我们可以使用这样的匿名对象来完成它。 12var http = new HttpClient();http.Post(\"url\", new&#123;Id=1, Genus=\"Fagus\"&#125;, HttpContentTypes.ApplicationJson); 或者您可以提交动态类型。 12345var tree = new ExpandoObject(); tree.Id = 1; tree.Genus = \"Fagus\";var http = new HttpClient();http.Post(\"url\", tree, HttpContentTypes.ApplicationJson); 您可以选择内容类型。","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Post","slug":"Post","permalink":"https://zfdev.com/tags/Post/"}]},{"title":"EasyHTTP - GetFile","slug":"EasyHTTP-GetFile","date":"2019-01-06T07:38:00.000Z","updated":"2019-01-06T08:43:14.617Z","comments":true,"path":"20190106/EasyHTTP-GetFile/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-GetFile/","excerpt":"","text":"您还可以通过提供要获取的文件的URI以及本地系统上的路径的文件名来获取您执行此操作的文件。 123var httpClient = new HttpClient();var filename = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), \"hello.gif\");httpClient.GetFile(\"http://localhost:16000/hello.gif\", filename);","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"GetFile","slug":"GetFile","permalink":"https://zfdev.com/tags/GetFile/"}]},{"title":"EasyHTTP - Streamresponse","slug":"EasyHTTP-Streamresponse","date":"2019-01-06T07:33:00.000Z","updated":"2019-01-06T08:41:41.299Z","comments":true,"path":"20190106/EasyHTTP-Streamresponse/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Streamresponse/","excerpt":"","text":"你也可以把响应体放在stream中 12345678910111213var httpClient = new HttpClient();httpClient.StreamResponse = true;httpClient.Get(\"http://localhost:16000/hello\");using (var stream = httpClient.Response.ResponseStream)&#123; int count; int total = 0; var buffer = new byte[8192]; while ((count = stream.Read(buffer, 0, buffer.Length)) &gt; 0) &#123; total += count; &#125;&#125; 将StremResponse设置为true时，RawText属性将为空。 1httpClient.Response.RawText","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Streamresponse","slug":"Streamresponse","permalink":"https://zfdev.com/tags/Streamresponse/"}]},{"title":"EasyHTTP - Get","slug":"EasyHTTP-Get","date":"2019-01-06T07:18:00.000Z","updated":"2019-01-06T16:35:25.923Z","comments":true,"path":"20190106/EasyHTTP-Get/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Get/","excerpt":"","text":"根据W3，Get方法执行以下操作。 GET方法意味着检索由Request-URI标识的任何信息（以实体的形式）。 如果Request-URI引用数据生成过程，则生成的数据应作为响应中的实体而不是过程的源文本返回，除非该文本恰好是过程的输出。 有几种方法可以使用Easyhttp获取。 在下面的所有示例中，我们假设在另一侧有一个服务，它返回带有Id属性和Genus属性的Tree的对象。 url /trees?Id=1 将为我们提供一个单独的Tree对象，我们可以这样做。 123456var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;var result = http.Get(\"http://localhost/trees?Id=1\");var tree = result.DynamicBody;Console.WriteLine(tree.Id);Console.WriteLine(tree.Genus); 或者我们可以使用这样的匿名对象。 123456var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;var result = http.Get(\"http://localhost/trees\", new &#123;Id = 1&#125; );var tree = result.DynamicBody;Console.WriteLine(tree.Id);Console.WriteLine(tree.Genus); 匿名对象将在向URL添加?Id=1然后执行get时进行转换。 我们也可以选择使用这样的动态ExpandoObject（这将产生与匿名对象相同的结果） 12345678var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;dynamic parameters = new ExpandoObject();parameters.Id = 1;var result = http.Get(\"http://localhost/trees\", parameters );var tree = result.DynamicBody;Console.WriteLine(tree.Id);Console.WriteLine(tree.Genus); 我们的服务可能无法解释命名参数url，只能理解像/trees/1这样的段。 然后我们可以指示easyhttp request对象在仍然使用匿名对象的同时使我们的URL成为这样。 像这样。 1234567var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;http.Request.ParametersAsSegments = true;var result = http.Get(\"http://localhost/trees\", new &#123;Id = 1&#125;);var tree = result.DynamicBody;Console.WriteLine(tree.Id);Console.WriteLine(tree.Genus); 以上内容与此相同 123456var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;var result = http.Get(\"http://localhost/trees/1\");var tree = result.DynamicBody;Console.WriteLine(tree.Id);Console.WriteLine(tree.Genus); 请注意，匿名对象中属性的顺序很重要。 例如 1http.Get(\"http://localhost/trees\", new &#123;Id = 1, Name = \"test\"&#125;); 将生成此网址http://localhost/trees/1/test 而以下代码 1http.Get(\"http://localhost/trees\", new &#123;Name = \"test\", Id = 1&#125;); 会生成 http://localhost/trees/test/1 我们当然也可以使用pocos（也支持ExpandoObjects）作为参数，而不是使用匿名对象。 如果您的服务以对象列表响应，那么您可以像这样读取它们。 12345678var http = new HttpClient();http.Request.Accept = HttpContentTypes.ApplicationJson;var trees = http.Get(\"http://localhost:55360/trees\");foreach(var t in trees.DynamicBody)&#123; Console.WriteLine(t.Id); Console.WriteLine(t.Genus);&#125; 你也可以使用 stream the response. 或者 get a file.","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Get","slug":"Get","permalink":"https://zfdev.com/tags/Get/"}]},{"title":"EasyHTTP - Httpstatuscode","slug":"EasyHTTP-Httpstatuscode","date":"2019-01-06T06:27:00.000Z","updated":"2019-01-06T08:42:38.260Z","comments":true,"path":"20190106/EasyHTTP-Httpstatuscode/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Httpstatuscode/","excerpt":"","text":"包含为HTTP定义的状态代码的值。 Continue = 100等效于HTTP状态100.System.Net.HttpStatusCode.Continue表示客户端可以继续其请求。 SwitchingProtocols = 101等效于HTTP状态101.System.Net.HttpStatusCode.SwitchingProtocols表示正在更改协议版本或协议。 OK = 200相当于HTTP状态200.System.Net.HttpStatusCode.OK表示请求成功，请求的信息在响应中。这是最常见的状态代码。 Created = 201等效于HTTP状态201.System.Net.HttpStatusCode.Created表示请求导致在发送响应之前创建新资源。 Accepted = 202等效于HTTP状态202.System.Net.HttpStatusCode.Accepted表示该请求已被接受进一步处理。 NonAuthoritativeInformation = 203等效于HTTP状态203.System.Net.HttpStatusCode.NonAuthoritativeInformation 表示返回的元信息来自原始服务器的缓存副本，因此可能是不正确的。 NoContent = 204等效于HTTP状态204.System.Net.HttpStatusCode.NoContent表示请求已成功处理并且响应内容为空。 ResetContent = 205等效于HTTP状态205.System.Net.HttpStatusCode.ResetContent表示客户端应重置（不重新加载）当前资源。 PartialContent = 206等效于HTTP状态206.System.Net.HttpStatusCode.PartialContent表示响应是包含字节范围的GET请求所请求的部分响应。 MultipleChoices = 300等效于HTTP状态300.System.Net.HttpStatusCode.MultipleChoices表示所请求的信息具有多个表示。默认操作是将此状态视为重定向，并按照与此响应关联的Location标头的内容进行操作。 Ambiguous = 300等效于HTTP状态300.System.Net.HttpStatusCode.Ambiguous表示所请求的信息具有多个表示。默认操作是将此状态视为重定向，并按照与此响应关联的Location标头的内容进行操作。 MovedPermanently = 301等效于HTTP状态301.System.Net.HttpStatusCode.MovedPermanently表示所请求的信息已移至Location头中指定的URI。收到此状态时的默认操作是遵循与响应关联的Location标头。 Moved = 301等效于HTTP状态301.System.Net.HttpStatusCode.Moved表示所请求的信息已移至Location头中指定的URI。收到此状态时的默认操作是遵循与响应关联的Location标头。当原始请求方法是POST时，重定向的请求将使用GET方法。 Found = 302等效于HTTP状态302.System.Net.HttpStatusCode.Found表示所请求的信息位于Location标头中指定的URI。收到此状态时的默认操作是遵循与响应关联的Location标头。当原始请求方法是POST时，重定向的请求将使用GET方法。 Redirect = 302等效于HTTP状态302.System.Net.HttpStatusCode.Redirect表示所请求的信息位于Location头中指定的URI。收到此状态时的默认操作是遵循与响应关联的Location标头。当原始请求方法是POST时，重定向的请求将使用GET方法。 SeeOther = 303等效于HTTP状态303.System.Net.HttpStatusCode.SeeOther自动将客户端重定向到作为POST结果的Location头中指定的URI。对Location标头指定的资源的请求将使用GET进行。 RedirectMethod = 303等效于HTTP状态303.作为POST的结果，System.Net.HttpStatusCode.RedirectMethod自动将客户端重定向到Location头中指定的URI。对Location标头指定的资源的请求将使用GET进行。 NotModified = 304等效于HTTP状态304. System.Net.HttpStatusCode.NotModified表示客户端的缓存副本是最新的。资源的内容不会传输。 UseProxy = 305等效于HTTP状态305.System.Net.HttpStatusCode.UseProxy表示请求应使用Location头中指定的URI处的代理服务器。 Unused = 306等效于HTTP状态306.System.Net.HttpStatusCode.Unused是 HTTP/1.1 规范的建议扩展，未完全指定。 TemporaryRedirect = 307等效于HTTP状态307.System.Net.HttpStatusCode.TemporaryRedirect指示请求信息位于Location头中指定的URI。收到此状态时的默认操作是遵循与响应关联的Location标头。当原始请求方法是POST时，重定向的请求也将使用POST方法。 RedirectKeepVerb = 307等效于HTTP状态307.System.Net.HttpStatusCode.RedirectKeepVerb指示请求信息位于Location头中指定的URI。收到此状态时的默认操作是遵循与响应关联的Location标头。当原始请求方法是POST时，重定向的请求也将使用POST方法。 BadRequest = 400等效于HTTP状态400.System.Net.HttpStatusCode.BadRequest表示服务器无法理解该请求。如果没有其他错误适用，或者确切错误未知或没有自己的错误代码，则会发送System.Net.HttpStatusCode.BadRequest。 Unauthorized = 401等效于HTTP状态401.System.Net.HttpStatusCode.Unauthorized指示所请求的资源需要身份验证。WWW-Authenticate标头包含有关如何执行身份验证的详细信息。 PaymentRequired = 402等效于HTTP状态402.保留System.Net.HttpStatusCode.PaymentRequired以供将来使用。 Forbidden = 403等效于HTTP状态403.System.Net.HttpStatusCode.Forbidden表示服务器拒绝满足请求。 NotFound = 404等效于HTTP状态404.System.Net.HttpStatusCode.NotFound指示服务器上不存在所请求的资源。 MethodNotAllowed = 405等效于HTTP状态405.System.Net.HttpStatusCode.MethodNotAllowed指示在请求的资源上不允许请求方法（POST或GET）。 NotAcceptable = 406等效于HTTP状态406.System.Net.HttpStatusCode.NotAcceptable指示客户端已使用Accept标头指示它不接受资源的任何可用表示。 ProxyAuthenticationRequired = 407等效于HTTP状态407.System.Net.HttpStatusCode.ProxyAuthenticationRequired指示所请求的代理需要身份验证。Proxy-authenticate标头包含有关如何执行身份验证的详细信息。 RequestTimeout = 408等效于HTTP状态408.System.Net.HttpStatusCode.RequestTimeout指示客户端在服务器期望请求的时间内未发送请求。 Conflict = 409等效于HTTP状态409.System.Net.HttpStatusCode.Conflict表示由于服务器上的冲突而无法执行请求。 Gone = 410等效于HTTP状态410.System.Net.HttpStatusCode.Gone表示请求的资源不再可用。 LengthRequired = 411等效于HTTP状态411.System.Net.HttpStatusCode.LengthRequired指示缺少所需的Content-length标头。 PreconditionFailed = 412等效于HTTP状态412.System.Net.HttpStatusCode.PreconditionFailed指示为此请求设置的条件失败，并且无法执行请求。条件使用条件请求标头设置，如If-Match，If-None-Match或If-Unmodified-Since。 RequestEntityTooLarge = 413等效于HTTP状态413.System.Net.HttpStatusCode.RequestEntityTooLarge指示请求对于服务器来说太大而无法处理。 RequestUriTooLong = 414等效于HTTP状态414.System.Net.HttpStatusCode.RequestUriTooLong表示URI太长。 UnsupportedMediaType = 415等效于HTTP状态415.System.Net.HttpStatusCode.UnsupportedMediaType指示请求是不受支持的类型。 RequestedRangeNotSatisfiable = 416等效于HTTP状态416.System.Net.HttpStatusCode.RequestedRangeNotSatisfiable指示无法返回从资源请求的数据范围，因为范围的开头位于资源的开头之前，或者范围的结尾位于资源的结束。 ExpectationFailed = 417等效于HTTP状态417.System.Net.HttpStatusCode.ExpectationFailed指示服务器无法满足Expect标头中给出的期望。 InternalServerError = 500等效于HTTP状态500.System.Net.HttpStatusCode.InternalServerError指示服务器上发生了一般错误。 NotImplemented = 501等效于HTTP状态501.System.Net.HttpStatusCode.NotImplemented指示服务器不支持所请求的功能。 BadGateway = 502等效于HTTP状态502.System.Net.HttpStatusCode.BadGateway指示中间代理服务器从另一个代理或源服务器收到错误响应。 ServiceUnavailable = 503等效于HTTP状态503.System.Net.HttpStatusCode.ServiceUnavailable指示服务器暂时不可用，通常是由于高负载或维护。 GatewayTimeout = 504等效于HTTP状态504.System.Net.HttpStatusCode.GatewayTimeout指示中间代理服务器在等待来自另一个代理或源服务器的响应时超时。 HttpVersionNotSupported = 505等效于HTTP状态505.System.Net.HttpStatusCode.HttpVersionNotSupported指示服务器不支持所请求的HTTP版本。","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"HTTP","slug":"HTTP","permalink":"https://zfdev.com/tags/HTTP/"},{"name":"HttpStatuscode","slug":"HttpStatuscode","permalink":"https://zfdev.com/tags/HttpStatuscode/"}]},{"title":"EasyHTTP - Response","slug":"EasyHTTP-Response","date":"2019-01-06T06:10:00.000Z","updated":"2019-01-06T08:41:52.403Z","comments":true,"path":"20190106/EasyHTTP-Response/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Response/","excerpt":"","text":"response对象将包含请求发出后从服务器返回的数据。 ContentType包含用于此响应的内容类型(contentype)的只读属性。 字符串类型。 StatusCode包含此响应返回的状态码的只读属性。 HttpStatusCode类型. StatusDescription包含用于此响应的状态描述的只读属性。 Cookies包含用于此响应的cookies的只读属性。 Age包含此响应时间的只读属性。 Allow包含用于此响应的httpmethods的只读属性。 CacheControl包含用于此响应的缓存控制的只读属性。 ContentEncoding包含用于此响应的内容编码的只读属性。 ContentLanguage包含用于此响应的内容语言的只读属性。 ContentLength包含用于此响应的内容长度的只读属性。 ContentLocation包含用于此响应的当前位置的只读属性。 ContentDisposition包含用于此响应的内容处理的只读属性。 Date包含用于此响应的日期的只读属性。 ETag包含用于此响应的实体标签(Entity Tag)的只读属性。 Expires包含用于此响应的过期的只读属性。 LastModified包含用于此响应的上次更改时间的只读属性。 Location包含用于此响应的位置的只读属性。 Pragma包含用于此响应的pragma的只读属性。 Server包含用于此响应的服务器的只读属性。 RawHeaders包含用于此响应的原始头信息的只读属性。 ResponseStream包含此响应的响应流的只读属性。 DynamicBodyRawTextStaticBody(string overrideContentType = null)","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Response","slug":"Response","permalink":"https://zfdev.com/tags/Response/"},{"name":"HTTP","slug":"HTTP","permalink":"https://zfdev.com/tags/HTTP/"}]},{"title":"EasyHTTP - Request","slug":"EasyHTTP-Request","date":"2019-01-06T06:00:00.000Z","updated":"2019-01-06T08:42:01.139Z","comments":true,"path":"20190106/EasyHTTP-Request/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Request/","excerpt":"","text":"request用于发送数据到服务器，可以根据自己的喜好进行配置。 Acceptaccept属性允许您从响应中设置所需的超媒体类型。 该字段是一个字符串，但为方便起见，还有一些常量可以在HttpContentypes类中使用。 你这样使用它。 1http.Request.Accept = HttpContentTypes.ApplicationJson; 或者你也可以写。 1http.Request.Accept = \"application/json\"; 这将要求响应将其内容编码为JSON。 这是HttpContenttypes中的另一种类型。 MultiPartFormData = “multipart/form-data”; TextPlain = “text/plain”; TextHtml = “text/html”; TextCsv = “text/csv”; ApplicationJson = “application/json”; ApplicationXml = “application/xml”; ApplicationXWwwFormUrlEncoded = “application/x-www-form-urlencoded”; ApplicationOctetStream = “application/octet-stream”; AcceptCharSetAcceptEncodingAcceptLanguageKeepAliveClientCertificatesContentLengthContentTypeContentEncodingCookiesDateExpectFromHostIfMatchIfModifiedSinceIfRangeMaxForwardsRefererRangeUserAgentRawHeadersMethod允许您获取并设置Request将使用的HttpMethod。 此属性是名为HttpMethod的枚举，它包含以下方法。 HEAD GET POST PUT DELETE OPTIONS PATCH 此属性也将根据您在HttpClient上使用的方法进行设置 DataUriPutFilenameMultiPartFormDataMultiPartFileDataTimeoutParametersAsSegments有关使用它的原因和方式的详细信息，请参阅Get","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Request","slug":"Request","permalink":"https://zfdev.com/tags/Request/"}]},{"title":"EasyHTTP - Httpclient","slug":"EasyHTTP-Httpclient","date":"2019-01-06T05:48:00.000Z","updated":"2019-01-06T08:42:11.420Z","comments":true,"path":"20190106/EasyHTTP-Httpclient/","link":"","permalink":"https://zfdev.com/20190106/EasyHTTP-Httpclient/","excerpt":"","text":"You can make a HttpClient like this.你可以这样创建一个HttpClient。 1var http = new HttpClient(); The empty constructor means that you will have to provide a url for each and every call (Get, Post, …) Or like this 空构造函数意味着您必须为每个调用提供一个URL（Get，Post，…） 或者像这样 1var http = new HttpClient(\"http://localhost\"); Here we instantiated the client with a baseuri. For all the calls you make with this client the baseuri will be prefixed to your uri. So this. 在这里，我们使用baseuri实例化客户端。 对于您使用此客户端发出的所有请求，baseuri将以uri为前缀。 如：12var http = new HttpClient(\"http://localhost\");var result = http.Get(\"/trees\"); is actually the same as writing. 上面的写法与下面是一样的。 12var http = new HttpClient(\"http://localhost\");var result = http.Get(\"http://localhost/trees\"); The httpclient object contains the Request and Response object. You can set properties on those objects to control the request and response. The httpclient also contains the following http verbs which you can use. httpclient对象包含Request和Response对象。 您可以在这些对象上设置属性以控制请求和响应。 httpclient还包含您可以使用的以下http方法。 Get Post Put Patch Options Head Delete","categories":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/categories/C/"},{"name":"EasyHTTP","slug":"C/EasyHTTP","permalink":"https://zfdev.com/categories/C/EasyHTTP/"},{"name":"Documentation","slug":"C/EasyHTTP/Documentation","permalink":"https://zfdev.com/categories/C/EasyHTTP/Documentation/"}],"tags":[{"name":"C#","slug":"C","permalink":"https://zfdev.com/tags/C/"},{"name":"EasyHTTP","slug":"EasyHTTP","permalink":"https://zfdev.com/tags/EasyHTTP/"},{"name":"Httpclient","slug":"Httpclient","permalink":"https://zfdev.com/tags/Httpclient/"}]},{"title":"Win7 重装日志 软件","slug":"Win7-重装日志","date":"2019-01-04T10:49:00.000Z","updated":"2019-01-06T10:38:00.123Z","comments":true,"path":"20190104/Win7-重装日志/","link":"","permalink":"https://zfdev.com/20190104/Win7-重装日志/","excerpt":"","text":"软件安装 7-zip (https://www.7-zip.org/) 输入法 搜狗输入法 (https://pinyin.sogou.com/) / 星空修改版 RIME(小狼毫) (https://rime.im/download/) 浏览器 Chrome (https://www.google.cn/chrome/) Chrome 开发者版 (https://www.google.cn/chrome/dev) 360极速浏览器 官方下载 浏览器插件 SwitchyOmega (https://github.com/FelisCatus/SwitchyOmega/releases) Fiddler (https://www.telerik.com/download/fiddler) Python 官方版本 (https://www.python.org/downloads/) AnaConda (https://www.anaconda.com/download/) PyChram (http://www.jetbrains.com/pycharm/download/) Everything (http://www.voidtools.com/downloads/) 语言包 (http://www.voidtools.com/Everything.lng.zip) Listary (https://www.listary.com/download) f.lux (https://justgetflux.com/) Sourcetree (https://www.sourcetreeapp.com/) 跳过注册","categories":[{"name":"Other","slug":"Other","permalink":"https://zfdev.com/categories/Other/"}],"tags":[{"name":"win7","slug":"win7","permalink":"https://zfdev.com/tags/win7/"}]},{"title":"PHP - 基础 - 流程控制","slug":"PHP-基础-流程控制","date":"2018-11-14T07:15:00.000Z","updated":"2018-11-14T07:34:20.196Z","comments":true,"path":"20181114/PHP-基础-流程控制/","link":"","permalink":"https://zfdev.com/20181114/PHP-基础-流程控制/","excerpt":"","text":"PHP的遍历数组的三种方式及各自区别 延伸：分支结构 PHP的遍历数组的三种方式及各自区别三种方式 使用for循环 使用foreach循环 使用while、list()、each()组合循环 区别 for 循环只能遍历索引数组； foreach 可以遍历索引和关联数组，联合使用list()，each()和while 循环同样可以遍历索引和关联数组； while、list()、each()组合不会 reset()； foreach遍历会对数组进行 reset() 操作； 分支结构if….elseif 在elseif语句中只能有一个表达式为 true ，即在elseif语句中只能有一个语句块被执行，多个elseif从句是排斥关系。 使用elseif语句有一个基本原则，总吧优先范围小的条件放在前面处理。12345678910&lt;?php $a = 5; if($a &lt; 3)&#123; &#125;elseif($a &gt; 3)&#123; &#125;else&#123; // $a == 3; &#125;?&gt; switch…case… 和 if 不同的是， switch后面的控制表达式的数据类型只能是整形、浮点类型或字符串 1234567891011121314&lt;?php $a = 5; switch($a)&#123; case 1; echo 'a = 1'; break; case 2: echo 'a = 2'; break; default: echo 'a 不是预期的数字'; break; &#125;?&gt; continue 语句作用到 switch 的作用类似于 break 跳出 switch 外的循环，可以使用 continue 2 效率 如果条件比一个简单的比较要复杂得多或者在一个很多次的循环中，那么使用 switch 语句可能会快一些 重点 理解循环内部机制，更易于记忆 foreach 的 reset 特性，分支结构中理解了 switch…case 的执行步骤也就不难理解为什么效率高了。 问题 PHP中如何优化多个if…elseif语句的情况？ 可能性较大的尽量往前挪； 如果判断的是一个比较复杂的结构，且判断的值是整型、浮点或字符串可以使用 switch…case","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zfdev.com/categories/PHP/"},{"name":"基础","slug":"PHP/基础","permalink":"https://zfdev.com/categories/PHP/基础/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://zfdev.com/tags/PHP/"},{"name":"基础","slug":"基础","permalink":"https://zfdev.com/tags/基础/"},{"name":"流程控制","slug":"流程控制","permalink":"https://zfdev.com/tags/流程控制/"}]},{"title":"PHP - 基础 - 运算符","slug":"PHP-基础-运算符","date":"2018-11-14T06:25:00.000Z","updated":"2018-11-14T07:13:36.035Z","comments":true,"path":"20181114/PHP-基础-运算符/","link":"","permalink":"https://zfdev.com/20181114/PHP-基础-运算符/","excerpt":"","text":"错误控制符@PHP的运算符的错误控制符@ PHP支持一个错误运算符：@。当将其放置在一个PHP表达式之前，该表达式可能产生的任何错误信息都将被忽略掉 PHP所有运算符运算符的优先级 括号的使用可以增加代码可读性， 推荐使用 递增/递减 &gt; ！ &gt; 算术运算符 &gt; 大小比较 &gt; (不)相等比较 &gt; 引用 &gt;位运算符(^) &gt; 位运算符(I) &gt; 逻辑与 &gt; 逻辑或 &gt; 三目 &gt; 赋值 &gt;and &gt; xor &gt; or 详细文档 PHP: 运算符优先级 比较运算符 ==和===的区别 ==: 比较值是否相等 ===: 比较值和类型是否相等 等值判断（FALSE的七种情况） 示例: 12345678&lt;?phpif (\"==false\" &amp;&amp; false) &#123;// 非空串为 true echo '1';&#125; elseif ('0' == 0) &#123; // '0' 空字符串0等于 false and 0 等于 false echo '2';&#125; elseif (0.0 == 0) &#123; // '0.0' 字符串0.0等于 false and 0 等于 false echo '3';&#125; 递增/递减运算符 递增/递减运算符不影响布尔值 递减 NULL 值没有效果 递增NULL(NULL++) 值为1 递增和递减在前就先运算符后返回，反之就先返回，后运算（++i, i++） 逻辑运算符 短路作用 || 和 &amp;&amp; 与 or 和 and 的优先级不同 重点: 递增/递减运算符的运算规则 逻辑运算符的短路效果 逻辑运算符多考虑优先级问题 问题12345678910111213141516171819202122232425&lt;?php/** * 下列程序中请写出打印输出的结果 * &lt;?php * $a = 0; * $b = 0; * if ($a = 3 &gt; 0 || $b = 3 &gt; 0) * &#123; * $a++; * $b++; * echo $a. \"\\n\"; * echo $b. \"\\n\"; * &#125; */$a = 0;$b = 0;if ($a = 3 &gt; 0 || $b = 3 &gt; 0) &#123; // $a = true; $b=0; $a++; // true 递增，还是 true $b++; // 0 递增，等于1 echo $a. \"\\n\"; echo $b. \"\\n\";&#125; 12345678910// 1: 3 &gt; 0 == true$a = true || $b = 3 &gt; 0// 2: 3 &gt; 0 == true$a = true || $b = true// 3: $a = true == true$a = true || $b = true// 4: true || $b == true$a = true// 5: $a = true == truetrue","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zfdev.com/categories/PHP/"},{"name":"基础","slug":"PHP/基础","permalink":"https://zfdev.com/categories/PHP/基础/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://zfdev.com/tags/PHP/"},{"name":"基础","slug":"基础","permalink":"https://zfdev.com/tags/基础/"},{"name":"运算符","slug":"运算符","permalink":"https://zfdev.com/tags/运算符/"},{"name":"优先级","slug":"优先级","permalink":"https://zfdev.com/tags/优先级/"}]},{"title":"PHP - 基础 - 常量及数据类型","slug":"PHP-基础-常量及数据类型","date":"2018-11-14T04:59:00.000Z","updated":"2018-11-14T06:09:07.570Z","comments":true,"path":"20181114/PHP-基础-常量及数据类型/","link":"","permalink":"https://zfdev.com/20181114/PHP-基础-常量及数据类型/","excerpt":"","text":"字符串PHP的字符串定义方式及各自区别定义方式 变量和变量, 变量和字符串, 字符串和字符串之间可以用.链接 单引号 不能解析变量 不能解析转义字符, 只能解析单引号和反斜线本身 效率更高 双引号 效率偏低 Heredoc 类似与双引号 Newdoc 类似于单引号 区别 单引号 1234567&lt;?php$a = 'hello world';// 单引号$str = 'a:$a';echo $str; // 输出: a:$a?&gt; 双引号 123&lt;?phpecho \"\\n\"; // 这里需要使用双引号, 单引号不解析转义?&gt; 双引号 1234&lt;?php$str = \"a:$a\";echo $str; // 输出 a:hello world?&gt; Heredoc 12345678910111213&lt;?php$str = &lt;&lt;&lt;EoT a-top $a a-bottomEoT;echo $str;/** 输出 a-top hello world a-bottom*/?&gt; Newdoc 12345678910111213&lt;?php$str = &lt;&lt;&lt;'EoT' a-top $a a-bottomEoT;echo $str; /** 输出 a-top $a a-bottom */?&gt; 数据类型 三大数据类型(标量, 复合, 特殊) 标量浮点类型 浮点类型不能运用到比较运算中(不能用于相等的判断) 12345678910&lt;?php $a = 0.1; $b = 0.7; if($a + $b == 0.8)&#123; &#125;else&#123; // false:$a+$b = 0.7999999999999999 不等于 0.8 &#125;?&gt; 布尔类型FALSE的七种情况 整型0、浮点0.0、空字符串、0字符串、布尔false、空数组、NULL 序号 类型 备注 1 0 整型0 2 0.0 浮点0.0 3 &#39;&#39; 空字符串 4 &#39;0&#39; 0字符串 5 false 布尔false 6 array() 空数组 7 NULL NULL 数组类型超全局数组 $GLOBALS // 包含 2-8 $_REQUEST //包含3-4, 尽量不使用,安全性偏低 $_GET $_POST $_SESSION $_COOKIE $_SERVER $_FIILES $_ENV $_SERVER 常用属性 $_SERVER[&#39;SERVER_ADDR&#39;] 服务器IP地址 $_SERVER[&#39;REMOTE_ADDR&#39;] 客户端IP地址 $_SERVER[&#39;SERVER_NAME&#39;] 服务器名称 $_SERVER[&#39;REQUEST_TIME&#39;] 请求时间 $_SERVER[&#39;HTTP_REFERER&#39;] 上级请求页面 $_SERVER[&#39;HTTP_USER_AGENT&#39;] 浏览器信息 $_SERVER[&#39;QUERY_STRING&#39;] 查询语句, ?后面的值 $_SERVER[&quot;REQUEST_URI&quot;] 域名后面的值，包括/ $_SERVER[&quot;SCRIPT_NAME&quot;] 获取当前脚本的名称 $_SERVER[&#39;HTTP_USER_AGENT&#39;] 浏览器信息 $_SERVER[&#39;PATH_INFO&#39;] NULL NULL的三种情况直接赋值未NULL, 未定义的变量, unset销毁的变量 常量 常量一经定义, 不能被修改, 不能被删除 定义方式 const 更快, 语言结构 define 函数 不能用于类类常量的定义, const可以 预定义常量 __FILE__ 文件路径名 __LINE__ 所在行号 __DIR__ 文件目录 __FUNCTION__ 函数名称 __CLASS__ 类名 __TRAIT__ 5.4特性 TRAIT名称 __METHOD__ 类名+方法名 __NAMESPACE__ NAMESPACE 问题 用PHP写出显示客户端IP与服务器IP的代码。 12345&lt;?phpecho '客户端IP;' . $_SERVER['REMOTE_ADDR'];echo '服务器IP;' . $_SERVER['SERVER_ADDR'];?&gt; __FILE__ 表示什么意思。 所在文件的文件路径+文件名称","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zfdev.com/categories/PHP/"},{"name":"基础","slug":"PHP/基础","permalink":"https://zfdev.com/categories/PHP/基础/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://zfdev.com/tags/PHP/"},{"name":"基础","slug":"基础","permalink":"https://zfdev.com/tags/基础/"},{"name":"常量","slug":"常量","permalink":"https://zfdev.com/tags/常量/"},{"name":"数据类型","slug":"数据类型","permalink":"https://zfdev.com/tags/数据类型/"}]},{"title":"PHP - 基础 - 引用变量","slug":"PHP-基础-引用变量","date":"2018-11-14T03:28:00.000Z","updated":"2018-11-14T04:57:56.911Z","comments":true,"path":"20181114/PHP-基础-引用变量/","link":"","permalink":"https://zfdev.com/20181114/PHP-基础-引用变量/","excerpt":"","text":"PHP的引用变量的概念及定义方式概念在PHP中引用意味着用不同的名字访问同一个变量内容. 定义方式 使用 &amp; 符号 PHP引用变量的原理工作原理 定义变量 Code 12345678910111213&lt;?php // 1.定义一个变量 (内存地址1) $a = range(0, 1000); // 2.定义变量b, 将a变量的值赋值给b (内存地址1) // COW: Copy On Write $b = $a; // ------------------- // $a, $b 指向同一内存空间 // -------------------?&gt; 图示 修改变量 Code 123456789 &lt;?php // 3.修改变量, (内存地址2) $a = range(0, 1000); // ------------------- // $a -&gt; (内存地址2) // $b -&gt; (内存地址1) // -------------------?&gt; 图示 引用变量 Code 1234567891011&lt;?php // 1.定义一个变量 (内存地址1) $a = range(0, 1000); // 2.引用变量, $b指向$a的内存地址 $b = &amp;$a; // ------------------- // $a -&gt; (内存地址2) // $b -&gt; (内存地址2) // -------------------?&gt; 图示 引用变量 Code 123456789 &lt;?php // 4.修改变量, (内存地址2的内容被修改) $a = range(0, 1000); // ------------------- // $a -&gt; (内存地址2) // $b -&gt; (内存地址2) // -------------------?&gt; 图示 unset unset 只会取消引用, 不会销毁空间 unset Code 12345678910111213 &lt;?php // 定义变量, ($a内存地址1) $a = 1; // 引用变量, ($b内存地址1) $b = &amp;$a; // 取消引用 unset($b); // ------------------- // $a -&gt; (内存地址1) // $b -&gt; NULL // -------------------?&gt; 图示 对象 修改对象属性时, 只会对修改的属性进行赋值, 不会将整个对象复制. 问题 写出如下程序的输出结果 123456&lt;?php $data = ['a', 'b', 'c']; foreach($data as $key =&gt; $val) &#123; $val = &amp;$data[$key]; &#125; 程序运行时, 每一次循环结束后变量$data的值是什么? 程序执行完成后, 变量$data的值是什么? 123456789101112131415161718192021// 程序共3次循环// 第一次: $key = 0; $val = 'a'; $val = &amp;$data[0] = 'a';// 此时 $data = ['a', 'b', 'c']// 第二次: $key = 1; $val = 'b'; // $data[0] 与 $val 指向同一内存, 所以 $data[0] = 'b'; $val = &amp;$data[1] = 'b';// 此时 $data = ['b', 'b', 'c']// 第三次: $key = 2; $val = 'c'; // $data[1] 与 $val 指向同一内存, 所以 $data[1] = 'c'; $val = &amp;$data[2] = 'c';// 此时 $data = ['b', 'c', 'c']// 执行完成后: $data = ['b', 'c', 'c'] 使用 memory_get_usage()获取当前使用的内存量 COW(Copy on Write)写入时复制: 一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时要求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（transparently）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://zfdev.com/categories/PHP/"},{"name":"基础","slug":"PHP/基础","permalink":"https://zfdev.com/categories/PHP/基础/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://zfdev.com/tags/PHP/"},{"name":"基础","slug":"基础","permalink":"https://zfdev.com/tags/基础/"},{"name":"引用变量","slug":"引用变量","permalink":"https://zfdev.com/tags/引用变量/"}]},{"title":"CSS选择器 匹配H标签","slug":"CSS选择器-匹配H标签","date":"2018-11-02T11:30:00.000Z","updated":"2018-11-02T11:31:25.983Z","comments":true,"path":"20181102/CSS选择器-匹配H标签/","link":"","permalink":"https://zfdev.com/20181102/CSS选择器-匹配H标签/","excerpt":"","text":"1$(&apos;.article :header&apos;) 匹配h1,h2之类的标题","categories":[{"name":"前端","slug":"前端","permalink":"https://zfdev.com/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"https://zfdev.com/tags/css/"}]},{"title":"ubuntu 16.04 配置Rime输入法（中州韵）","slug":"ubuntu-16-04-配置Rime输入法（中州韵）","date":"2018-11-02T11:30:00.000Z","updated":"2018-11-02T11:37:47.290Z","comments":true,"path":"20181102/ubuntu-16-04-配置Rime输入法（中州韵）/","link":"","permalink":"https://zfdev.com/20181102/ubuntu-16-04-配置Rime输入法（中州韵）/","excerpt":"","text":"安装 1sudo apt install fcitx-rime 添加输入法 我是直接在系统设置里添加 安装小鹤双拼 1sudo apt-get install librime-data-double-pinyin 修改输入法配置 1~/.config/rime/default.custom.yaml customization: distribution_code_name: Weasel distribution_version: 0.9.30 generator: &quot;Rime::SwitcherSettings&quot; modified_time: &quot;Mon Jul 21 11:07:43 2014&quot; rime_version: 1.1.2 patch: &quot;ascii_composer/good_old_caps_lock&quot;: true &quot;ascii_composer/switch_key&quot;: Caps_Lock: commit_code Control_L: commit_code Control_R: noop Shift_L: noop Shift_R: commit_code &quot;menu/page_size&quot;: 5 schema_list: - {schema: luna_pinyin} # 朙月拼音 #- {schema: cangjie5} # 倉頡五代 - {schema: luna_pinyin_fluency} #- {schema: luna_pinyin_simp} # 朙月拼音 简化字模式 #- {schema: luna_pinyin_tw} # 朙月拼音 臺灣正體模式 - {schema: double_pinyin_flypy} # 小鶴雙拼 &quot;switcher/hotkeys&quot;: - &quot;Control+grave&quot;","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zfdev.com/categories/Ubuntu/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://zfdev.com/tags/ubuntu/"},{"name":"Rime","slug":"Rime","permalink":"https://zfdev.com/tags/Rime/"},{"name":"输入法","slug":"输入法","permalink":"https://zfdev.com/tags/输入法/"}]},{"title":"Django2.0 配置静态文件路由，验证网站所有权","slug":"Django2-0-配置静态文件路由，验证网站所有权","date":"2018-11-02T11:29:00.000Z","updated":"2018-11-02T11:44:54.228Z","comments":true,"path":"20181102/Django2-0-配置静态文件路由，验证网站所有权/","link":"","permalink":"https://zfdev.com/20181102/Django2-0-配置静态文件路由，验证网站所有权/","excerpt":"","text":"Django2.0 配置静态文件路由这个有什么用？在 Google Analytics（分析）、百度统计 添加网站时需要验证网站所有权，这时一般有几种验证方式 如 Google： HTML 文件 - 上传将 HTML 文件上传到您的网站。 HTML 标记 - 向您网站的首页添加元标记。 域名提供商 - 登录到您的域名提供商网站。 Google 跟踪代码管理器 本文就是配置为了 1. HTML 文件， 为什么要用 HTML 文件 来验证？ HTML 标记 需要在网站首页添加&lt;meta&gt; 标签，强迫症，不想加 域名提供商 因为把裸域设成了CNAME，所有用不了这个（好像不应该设置裸域） Google 跟踪代码管理器 不知道为什么添加不了，以后再看 HTML文件 就剩你了 设置方法 导入静态视图 django.contrib.staticfiles.views.serve视图会在静态文件目录查找指定的path文件 也就是要把HTML文件存放在STATIC目录,或者指定document_root 设置urls.py1fromc 添加路由 使用django.urls.path 1234 path('googledadae4a424161111.html', serve, kwargs=&#123;'path':'googledadae4a424161111.html'&#125;, name='googleAnalytics'), 使用django.conf.urls.url django2.0 添加了re_path，url是re_path的别名，完全调用re_path 1234urlpatterns = [# .... 其他配置url(r'^googledadae4a424161111.html$', serve, name='googleAnalytics'),] 懒人专用配置 匹配所有html文件 1234urlpatterns = [# .... 其他配置url(r'^(?P&lt;path&gt;[a-zA-Z0-9]*\\.html)$', serve, name='html_file'),]","categories":[{"name":"Django","slug":"Django","permalink":"https://zfdev.com/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://zfdev.com/tags/Python/"},{"name":"静态文件","slug":"静态文件","permalink":"https://zfdev.com/tags/静态文件/"},{"name":"DJango","slug":"DJango","permalink":"https://zfdev.com/tags/DJango/"}]},{"title":"ubuntu 16.04 python 3.x 安装OpenSSL","slug":"ubuntu-16-04-python-3-x-安装OpenSSL","date":"2018-11-02T11:29:00.000Z","updated":"2018-11-02T11:38:15.828Z","comments":true,"path":"20181102/ubuntu-16-04-python-3-x-安装OpenSSL/","link":"","permalink":"https://zfdev.com/20181102/ubuntu-16-04-python-3-x-安装OpenSSL/","excerpt":"","text":"错误提示：1Can&apos;t connect to HTTPS URL because the SSL module is not available. 连接HTTPS时，提示SSL不可用 测试12# 进入python$ python3 # or python3.6 12# 导入SSL模块&gt;&gt;&gt; import ssl 如果出现下面提示，则Python不支持SSL。 解决方案下载文件 OpenSSL $ wget http://www.openssl.org/source/openssl-1.0.2e.tar.gz Python3.6 - 选择需要的版本 $wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz 安装OpenSSL1234# 解压文件tar xvzf openssl-1.0.2e.tar.gz# 进入目录$ ./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl 123$ make$ make test$ sudo make install Python进入目录123#解压$ tar xvzf Python-3.6.2.tgz$ cd Python-3.6.2 修改安装配置 使用VIM打开文件Modules/Setup.dist文件，搜索SSL，取消四行注释 1$ vim Modules/Setup.dist 开始安装 完成上面操作就可以安装了，执行下面3行代码 123$ ./configure$ make$ sudo make install 完成！ 不出意外已经安装完成，下面检测一下。 进入python 1$ python3 导入SSL模块 1&gt;&gt;&gt; import ssl 没有报错就已经成功了！","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zfdev.com/categories/Ubuntu/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zfdev.com/tags/Ubuntu/"},{"name":"python3","slug":"python3","permalink":"https://zfdev.com/tags/python3/"},{"name":"OpenSSL","slug":"OpenSSL","permalink":"https://zfdev.com/tags/OpenSSL/"}]},{"title":"Python 基础 - 数据类型 - 字符串类型与操作","slug":"Python-基础-数据类型-字符串类型与操作","date":"2018-11-02T11:28:00.000Z","updated":"2018-11-02T11:39:54.874Z","comments":true,"path":"20181102/Python-基础-数据类型-字符串类型与操作/","link":"","permalink":"https://zfdev.com/20181102/Python-基础-数据类型-字符串类型与操作/","excerpt":"","text":"#数据类型 字符串 str格式 单引号 双引号 三引号 多行. 利用其特点,可用于注释 1. 切片(同列表) 使用[M:N:K]根据步长对字符串切片M 缺失表示至开头N 缺失表示至结尾K 缺失表示步长1 正向递增序号 ‘hello world’[:5] == ‘hello’ 反向递减序号 ‘hello world’[-5:] == ‘world’ 步长 ‘1234567890’[::2] == ‘13579’ 步长为负, 反转字符串 ‘1234567890’[::-1] == ‘0987654321’ 2. 转义符 (在行尾时) 续行符 \\\\ 反斜杠符号 \\’ 单引号 \\” 双引号 \\b 退格(Backspace,光标向前退一格) \\000 空 \\n 换行(光标移动到下行首) \\r 回车(光标移动到本行首) \\t 横向制表符 \\a 响铃 \\e 转义 \\v 纵向制表符 \\f 换页 \\oyy 八进制数，yy代表的字符，例如：\\o12代表换行 \\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行 \\other 其它的字符以普通格式输出 3. 字符串操作符x + y- 连接两个字符串x和y n*x 或 x*n- 复制n次字符串x x in s- 如果x是s的子串, 返回True, 否则返回False 4. 字符串处理函数len(x)- 长度, 返回字符串x的长度 - len(&quot;一二三456&quot;) 结果为6 str(x)- 任意类型x所对应的字符串形式 - str(1.23) 结果为&quot;1.23&quot; - str([1, 2]) 结果为&quot;[1, 2]&quot; hex(x)- 整数x的十六进制小写形式字符串 - hex(425) 结果为&quot;0x1a9&quot; oct(x)- 整数x的八进制小写形式字符串 - oct(425) 结果为&quot;0o651&quot; chr(u)- u为Unicode编码, 返回其对应的字符 ord(x)- x为字符, 返回其对应的Unicode编码 str.lower()- 返回字符串的副本, 全部字符小写 - &apos;AbcDeF&apos;.upper() 结果为&quot;abcdef&quot; str.upper()- 返回字符串的副本, 全部字符大写 - &apos;AbcDeF&apos;.upper() 结果为&quot;ABCDEF&quot; str.split(sep=None)- 返回一个列表, 由str根据sep被分割的部分组成 - &quot;A,B,C&quot;.split(&quot;,&quot;) 结果为[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;] str.count(sub)- 返回子串sub在str中出现的次数 - &quot;a apple a day&quot;.count(&quot;a&quot;) 结果为4 str.replace(old, new)- 返回字符串str副本, 所有old子串被替换为new - &quot;python&quot;.replace(&quot;n&quot;, &quot;n123&quot;) 结果为&quot;python123&quot; str.center(width, fillchar=” “)- 字数串str根据宽度width居中, fillchar可选 - &quot;python&quot;.center(10,&apos;=&apos;) 结果为&apos;==python==&apos; str.strip(chars)- 从str中去掉在其左侧和右侧,chars中列出的字符 - &quot;== python ==&quot;.strip(&quot; =pn&quot;) 结果为&quot;ytho&quot; str.join(iter)- 主要用于字符串分割 - 在iter变量除最后元素外每个元素后增加一个str - &quot;,&quot;.join(&quot;12345&quot;) 结果为 &quot;1,2,3,4,5&quot; ### 5. 字符串格式化 “{0} / {1} / {2}”.format(2018, 10, 24) >> 2018 / 10 / 24 {序号} 为槽 槽的内部对格式化的配置方式{&lt;参数序号&gt;:&lt;格式控制标记&gt;}:&lt;填充&gt;|&lt;对齐&gt;|&lt;宽度&gt;|&lt;,&gt;|&lt;.精度&gt;|&lt;类型&gt; 填充 用于填充的单个字符 对齐 &lt; 左对齐 > 右对齐 ^ 居中对齐 宽度 槽设定的输出宽度 ,(逗号) 数字的千位分隔符 .精度 浮点数小数精度 或 字数串最大输出长度 类型 整数类型 b c d o x X 浮点数类型 e E f % 示例123\"&#123;0:=^50,.3f&#125;\".format(500000.12345)'===================500,000.123====================' 0 序号 = 填充 ^ 居中对齐 50 宽度50 , 千位分割 .3 保留3为小数 f 浮点类型 EndAD https://zfdev.com https://dxx.fun","categories":[{"name":"Python","slug":"Python","permalink":"https://zfdev.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://zfdev.com/tags/Python/"},{"name":"字符串","slug":"字符串","permalink":"https://zfdev.com/tags/字符串/"},{"name":"String","slug":"String","permalink":"https://zfdev.com/tags/String/"}]},{"title":"ubuntu安装node vue","slug":"ubuntu安装node-vue","date":"2018-11-02T11:28:00.000Z","updated":"2018-11-02T11:38:32.773Z","comments":true,"path":"20181102/ubuntu安装node-vue/","link":"","permalink":"https://zfdev.com/20181102/ubuntu安装node-vue/","excerpt":"","text":"Nodejs 下载 1https://nodejs.org/dist/v8.11.1/node-v8.11.1-linux-x64.tar.xz 解压 1# 安装(移动) 12$sudo mkdir /usr/local/node/$sudo mv node-v8.11.1-linux-x64 /usr/local/node/v8.11.1 软链接 12$sudo ln -s /usr/local/node/v8.11.1/bin/node /usr/local/bin/node$sudo ln -s /usr/local/node/v8.11.1/bin/npm /usr/local/bin/npm 安装cnpm 12$sudo npm install -g cnpm --registry=https://registry.npm.taobao.org$sudo ln -s /usr/local/node/v8.11.1/bin/cnpm /usr/local/bin/cnpm 添加环境变量 1vim ~/.bashrc .bashrc 123export NODE_HOME=/usr/local/node/v8.11.1/export PATH=$PATH:$NODE_HOME/bin export NODE_PATH=$NODE_HOME/lib/node_modules 执行 1source ~/.bashrc VUE 安装1sudo cnpm install --global vue-cli","categories":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zfdev.com/categories/Ubuntu/"}],"tags":[{"name":"Node","slug":"Node","permalink":"https://zfdev.com/tags/Node/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://zfdev.com/tags/Ubuntu/"},{"name":"Vue","slug":"Vue","permalink":"https://zfdev.com/tags/Vue/"}]},{"title":"Django 2.0 静态文件404解决方法","slug":"Django-2-0-静态文件404解决方法","date":"2018-11-02T11:27:00.000Z","updated":"2018-11-02T11:45:57.244Z","comments":true,"path":"20181102/Django-2-0-静态文件404解决方法/","link":"","permalink":"https://zfdev.com/20181102/Django-2-0-静态文件404解决方法/","excerpt":"","text":"Django 在 Debug=True 时, 不需要配置. Django会在App中需找STATIC路径.因为服务器一直用Nginx配置STATIC路径, 所以一直没有配置开发环境的STATIC路径,但需要测试生产环境还是不方便, 所以设置一下Django中的STATIC路由. 配置project/urls.pyfrom django.views.static import serve urlpatterns = [ url(r&apos;^static/(?P&lt;path&gt;.*)$&apos;, serve, {&apos;document_root&apos;: settings.STATIC_ROOT}, name=&apos;static&apos;), ... ] project/settings.pyINSTALLED_APPS = [ &apos;django.contrib.staticfiles&apos;, ...... ] STATIC_URL = &apos;/static/&apos; STATIC_ROOT = os.path.join(BASE_DIR, &apos;static&apos;) STATICFILES_DIRS = ( os.path.join(BASE_DIR, &apos;apps/appname/static/&apos;), ) 路径STATIC project/static/… http://127.0.0.1:8000/static/... APP_STATIC project/.?/appname/STATIC http://127.0.0.1:8000/static/... 部署时使用需收集App下的STATIC文件到project/static/, 命令 python manage.py collectstatic EndAD https://dxx.fun/c/Python.htmlhttps://zfdev.com","categories":[{"name":"Django","slug":"Django","permalink":"https://zfdev.com/categories/Django/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://zfdev.com/tags/Python/"},{"name":"Django","slug":"Django","permalink":"https://zfdev.com/tags/Django/"},{"name":"静态文件","slug":"静态文件","permalink":"https://zfdev.com/tags/静态文件/"}]},{"title":"python虚拟环境 Virtualenv及Virtualenvwrapper","slug":"python虚拟环境-Virtualenv及Virtualenvwrapper","date":"2018-11-02T11:27:00.000Z","updated":"2018-11-02T11:39:26.676Z","comments":true,"path":"20181102/python虚拟环境-Virtualenv及Virtualenvwrapper/","link":"","permalink":"https://zfdev.com/20181102/python虚拟环境-Virtualenv及Virtualenvwrapper/","excerpt":"","text":"虚拟环境虚拟环境原理介绍： 虚拟环境相当于一个抽屉，在这个抽屉中安装的任何软件包都不会影响到其他抽屉。并且在项目中，我可以指定这个项目的虚拟环境来配合我的项目。比如我们现在有一个项目是基于Django 1.10.x版本，又有一个项目是基于Django 0.9.x的版本，那么这时候就可以创建两个虚拟环境，在这两个虚拟环境中分别安装Django 1.10.x和Django 0.9.x来适配我们的项目。 virtualenv安装virtualenv：virtualenv是用来创建虚拟环境的软件工具，我们可以通过pip或者pip3来安装： pip install virtualenv pip3 install virtualenv 创建虚拟环境：创建虚拟环境非常简单，通过以下命令就可以创建了： virtualenv [虚拟环境的名字] 如果你当前的Python3/Scripts的查找路径在Python2/Scripts的前面，那么将会使用python3作为这个虚拟环境的解释器。如果python2/Scripts在python3/Scripts前面，那么将会使用Python2来作为这个虚拟环境的解释器。 进入环境：虚拟环境创建好了以后，那么可以进入到这个虚拟环境中，然后安装一些第三方包，进入虚拟环境在不同的操作系统中有不同的方式，一般分为两种，第一种是Windows，第二种是*nix： windows进入虚拟环境：进入到虚拟环境的Scripts文件夹中，然后执行activate。 *nix进入虚拟环境：source /path/to/virtualenv/bin/activate 一旦你进入到了这个虚拟环境中，你安装包，卸载包都是在这个虚拟环境中，不会影响到外面的环境。 退出虚拟环境：退出虚拟环境很简单，通过一个命令就可以完成： deactivate 创建虚拟环境的时候指定Python解释器：在电脑的环境变量中，一般是不会去更改一些环境变量的顺序的。也就是说比如你的Python2/Scripts在Python3/Scripts的前面，那么你不会经常去更改他们的位置。但是这时候我确实是想在创建虚拟环境的时候用Python3这个版本，这时候可以通过-p参数来指定具体的Python解释器： virtualenv -p C:\\Python36\\python.exe [virutalenv name] virtualenvwrapper： virtualenvwrapper这个软件包可以让我们管理虚拟环境变得更加简单。不用再跑到某个目录下通过virtualenv来创建虚拟环境，并且激活的时候也要跑到具体的目录下去激活。 安装virtualenvwrapper：*nix：pip install virtualenvwrapper windowspip install virtualenvwrapper-win virtualenvwrapper基本使用：创建虚拟环境：mkvirtualenv my_env 那么会在你当前用户下创建一个Env的文件夹，然后将这个虚拟环境安装到这个目录下。如果你电脑中安装了python2和python3，并且两个版本中都安装了virtualenvwrapper，那么将会使用环境变量中第一个出现的Python版本来作为这个虚拟环境的Python解释器。 切换到某个虚拟环境：workon my_env 退出当前虚拟环境：deactivate 删除某个虚拟环境：rmvirtualenv my_env 列出所有虚拟环境：lsvirtualenv 进入到虚拟环境所在的目录：cd virtualenv 修改mkvirtualenv的默认路径：在我的电脑-&gt;右键-&gt;属性-&gt;高级系统设置-&gt;环境变量-&gt;系统变量中添加一个参数WORKON_HOME，将这个参数的值设置为你需要的路径。 创建虚拟环境的时候指定Python版本：在使用mkvirtualenv的时候，可以指定–python的参数来指定具体的python路径： mkvirtualenv --python==C:\\Python36\\python.exe hy_env virtualenvwrapper 命令的完全列表 参考：http://pythonguidecn.readthedocs.io/zh/latest/dev/virtualenvs.html EndAD","categories":[{"name":"Python","slug":"Python","permalink":"https://zfdev.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://zfdev.com/tags/Python/"},{"name":"Virtualenv","slug":"Virtualenv","permalink":"https://zfdev.com/tags/Virtualenv/"},{"name":"Virtualenvwrapper","slug":"Virtualenvwrapper","permalink":"https://zfdev.com/tags/Virtualenvwrapper/"}]},{"title":"pm2","slug":"pm2","date":"2018-11-02T11:16:00.000Z","updated":"2018-11-02T11:34:28.122Z","comments":true,"path":"20181102/pm2/","link":"","permalink":"https://zfdev.com/20181102/pm2/","excerpt":"","text":"run.js12345678910//runconst &#123; exec &#125; = require(&apos;child_process&apos;)exec(&apos;hexo server -i 0.0.0.0 -p 8020 -d&apos;,(error, stdout, stderr) =&gt; &#123; if(error)&#123; console.log(&apos;exec error: $&#123;error&#125;&apos;) return &#125; console.log(&apos;stdout: $&#123;stdout&#125;&apos;); console.log(&apos;stderr: $&#123;stderr&#125;&apos;);&#125;) source","categories":[{"name":"前端","slug":"前端","permalink":"https://zfdev.com/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zfdev.com/tags/Hexo/"},{"name":"Node","slug":"Node","permalink":"https://zfdev.com/tags/Node/"},{"name":"pm2","slug":"pm2","permalink":"https://zfdev.com/tags/pm2/"}]},{"title":"hexo-admin deploy","slug":"hexo-admin-deploy","date":"2018-11-02T11:09:00.000Z","updated":"2018-11-02T11:34:49.955Z","comments":true,"path":"20181102/hexo-admin-deploy/","link":"","permalink":"https://zfdev.com/20181102/hexo-admin-deploy/","excerpt":"","text":"1. _config.yml12admin: deployCommand: &apos;sh hexo-deploy.sh&apos; 2. hexo-deploy.sh1hexo g -d 3. blog\\node_modules\\hexo-admin\\deploy.js old 1var proc = spawn(command, [message], &#123;detached: true&#125;); new 1var proc = spawn((process.platform === &quot;win32&quot; ? &quot;hexo.cmd&quot; : &quot;hexo&quot;), [&apos;d&apos;, &apos;-g&apos;]);","categories":[{"name":"前端","slug":"前端","permalink":"https://zfdev.com/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zfdev.com/tags/Hexo/"},{"name":"deploy","slug":"deploy","permalink":"https://zfdev.com/tags/deploy/"}]}]}